\documentclass[12pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
%\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{15pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{blue},
commentstyle=\color{gray},
basicstyle=\footnotesize,
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{blue},
tabsize=4,
basicstyle=\ttfamily\footnotesize % fonte
}

\title{Rábalabaxúrias [UFMG]}
\author{Bruno Monteiro, Pedro Papa e Rafael Grandsire}


\begin{document}
\twocolumn
\date{} %tira a data
\maketitle


\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice
\tableofcontents


%%%%%%%%%%%%%%%%%%%%
%
% Strings
%
%%%%%%%%%%%%%%%%%%%%

\section{Strings}

\subsection{Suffix Array}
\begin{lstlisting}
// kasai recebe o suffix array e calcula lcp[i],
// o lcp entre s[sa[i],...,n-1] e s[sa[i+1],..,n-1]
//
// Complexidades:
// suffix_array - O(n log(n))
// kasai - O(n)

vector<int> suffix_array(string s) {
	s += "$";
	int n = s.size(), N = max(n, 260);
	vector<int> sa(n), ra(n);
	for(int i = 0; i < n; i++) sa[i] = i, ra[i] = s[i];

	for(int k = 0; k < n; k ? k *= 2 : k++) {
		vector<int> nsa(sa), nra(n), cnt(N);

		for(int i = 0; i < n; i++) nsa[i] = (nsa[i]-k+n)%n, cnt[ra[i]]++;
		for(int i = 1; i < N; i++) cnt[i] += cnt[i-1];
		for(int i = n-1; i+1; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i];

		for(int i = 1, r = 0; i < n; i++) nra[sa[i]] = r += ra[sa[i]] !=
			ra[sa[i-1]] or ra[(sa[i]+k)%n] != ra[(sa[i-1]+k)%n];
		ra = nra;
	}
	return vector<int>(sa.begin()+1, sa.end());
}

vector<int> kasai(string s, vector<int> sa) {
	int n = s.size(), k = 0;
	vector<int> ra(n), lcp(n);
	for (int i = 0; i < n; i++) ra[sa[i]] = i;

	for (int i = 0; i < n; i++, k -= !!k) {
		if (ra[i] == n-1) { k = 0; continue; }
		int j = sa[ra[i]+1];
		while (i+k < n and j+k < n and s[i+k] == s[j+k]) k++;
		lcp[ra[i]] = k;
	}
	return lcp;
}
\end{lstlisting}

\subsection{Algoritmo Z}
\begin{lstlisting}
// Complexidades:
// z - O(|s|)
// match - O(|s| + |p|)

vector<int> get_z(string s) {
    int n = s.size();
    vector<int> z(n, 0);

    // intervalo da ultima substring valida
    int l = 0, r = 0;
    for (int i = 1; i < n; i++) {
        // estimativa pra z[i]
        if (i <= r) z[i] = min(r - i + 1, z[i - l]);
        // calcula valor correto
        while (i + z[i] < n and s[z[i]] == s[i + z[i]]) z[i]++;
        // atualiza [l, r]
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }

    return z;
}

// quantas vezes p aparece em s
int match(string s, string p) {
    int n = s.size(), m = p.size();
    vector<int> z = get_z(p + s);

    int ret = 0;
    for (int i = m; i < n + m; i++)
        if (z[i] >= m) ret++;
   
    return ret;
}

\end{lstlisting}

\subsection{KMP}
\begin{lstlisting}
// Primeiro chama a funcao process com o padrao
// Depois chama match com (texto, padrao)
// Vai retornar o numero de ocorrencias do padrao
// p eh 1-based
//
// Complexidades:
// process - O(m)
// match - O(n + m)
// n = |texto| e m = |padrao|

int p[MAX];

void process(string& s) {
	int i = 0, j = -1;
	p[0] = -1;
	while (i < s.size()) {
		while (j >= 0 and s[i] != s[j]) j = p[j];
		i++, j++;
		p[i] = j;
	}
}

int match(string& s, string& t) {
	process(t);
	int i = 0, j = 0, ans = 0;
	while (i < s.size()) {
		while (j >= 0 and s[i] != t[j]) j = p[j];
		i++, j++;
		if (j == t.size()) j = p[j], ans++;
	}
	return ans;
}
\end{lstlisting}

\subsection{String hashing}
\begin{lstlisting}
// String deve ter valores [1, x]
// p deve ser o menor primo maior que x
// Para evitar colisao: testar mais de um
// mod; so comparar strings do mesmo tamanho
// ex : str_hash<31, 1e9+7> h(s);
//      ll val = h(10, 20);
//
// Complexidades:
// build - O(|s|)
// get_hash - O(1)

typedef long long ll;

template<int P, int MOD> struct str_hash {
	int n;
	string s;
	vector<ll> h, power;
	str_hash(string s_): n(s_.size()), s(s_), h(n), power(n){
		power[0] = 1;
		for (int i = 1; i < n; i++) power[i] = power[i-1]*P % MOD;
		h[0] = s[0];
		for (int i = 1; i < n; i++) h[i] = (h[i-1]*P + s[i]) % MOD;
	}
	ll operator()(int i, int j){
		if (!i) return h[j];
		return (h[j] - h[i-1]*power[j-i+1] % MOD + MOD) % MOD;
	}
};
\end{lstlisting}

\subsection{Suffix Array Rafael}
\begin{lstlisting}
// O(n log^2(n))

struct suffix_array{
	string &s;
	int n;
	vector<int> p, r, aux, lcp;
	seg_tree<int, min_el> st;
	suffix_array(string &s):
		s(s), n(s.size()), p(n), r(n), aux(n), lcp(n){
			for (int i = 0; i < n; i++){
				p[i] = i;
				r[i] = s[i];
			}
			auto rank = [&](int i){
				if (i >= n) return -i;
				return r[i];
			};
			for (int d = 1; d < n; d *= 2){
				auto t = [&](int i){
					return make_pair(rank(i), rank(i+d));
				};
				sort(p.begin(), p.end(),
						[&](int &i, int &j){
						return t(i) < t(j);
						}
					);
				aux[p[0]] = 0;
				for (int i = 1; i < n; i++)
					aux[p[i]] = aux[p[i-1]] + (t(p[i]) > t(p[i-1]));
				for (int j = 0; j < n; j++) r[j] = aux[j];
				if (aux[p[n-1]] == n-1) break;
			}

			int h = 0;
			for (int i = 0; i < n; i++){
				if (r[i] == n-1){
					lcp[r[i]] = 0;
					continue;
				}
				int j = p[r[i] + 1];
				while (i + h < n && j + h < n && s[i+h] == s[j+h]) h++;
				lcp[r[i]] = h;
				h = max(0, h-1);
			}
			st = seg_tree<int, min_el>(&lcp);
		}
	int query(int l, int r){
		return st.query(l, r);
	}
	ll distinct_substrings(){
		ll ans = p[0] + 1;
		for (int i = 1; i < n; i++)
			ans += p[i] - lcp[i-1] + 1;
		return ans;
	}
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Primitivas
%
%%%%%%%%%%%%%%%%%%%%

\section{Primitivas}

\subsection{Primitivas de matriz (Rafael)}
\begin{lstlisting}
ll mod(ll v){ return (v + MOD) % MOD; }
ll sum(ll l, ll r){ return mod(l+r); }
ll mult(ll l, ll r){ return mod(l*r); }
ll inverse(ll l){ return inv(l, MOD); }
bool equal(ll l, ll r){ return mod(l-r) == 0; }

template<typename T> struct matrix {
	vector<vector<T>> in;
	int row, col;

	void print(){//
		for (int i = 0; i < row; i++){
			for (int j = 0; j < col; j++)
				cout << in[i][j] << " ";
			cout << endl;
		}
	}

	matrix(int row, int col, int op = 0):row(row), col(col), in(row, vector<T>(col, 0)){
		if (op) for (int i = 0; i < row; i++) in[i][i] = 1;
	}
	matrix(initializer_list<initializer_list<T>> c):
		row(c.size()), col((*c.begin()).size()){
			in = vector<vector<T>>(row, vector<T>(col, 0));
			int i, j;
			i = 0;
			for (auto &it : c){
				j = 0;
				for (auto &jt : it){
					in[i][j] = jt;
					j++;
				}
				i++;
			}
		}
	T &operator()(int i, int j){ return in[i][j]; }
	//in case of a transposed matrix, swap i and j
	matrix<T>& operator*=(T t){
		matrix<T> &l = *this;
		for (int i = 0; i < row; i++)
			for (int j = 0; j < col; j++)
				l(i, j) = mult(l(i, j), t); //% MOD) % MOD;
		return l;
	}
	matrix<T> operator+(matrix<T> &r){
		matrix<T> &l = *this;
		matrix<T> m(row, col, 0);
		for (int i = 0; i < row; i++)
			for (int j = 0; j < col; j++)
				m(i, j) = sum(l(i, j), r(i, j)); //% MOD) % MOD;
		return m;
	}
	matrix<T> operator*(matrix<T> &r){
		matrix<T> &l = *this;
		int row = l.row;
		int col = r.col;
		int K = l.col;
		matrix<T> m(row, col, 0);
		for (int i = 0; i < row; i++)
			for (int j = 0; j < col; j++)
				for (int k = 0; k < K; k++)
					m(i, j) = sum(m(i, j), mult(l(i, k), r(k, j)));
		return m;
	}
	matrix<T> operator^(long long e){
		matrix<T> &m = (*this);
		if (e == 0) return matrix(m.row, m.row, 1);
		if (e == 1) return m;
		if (e == 2) return m*m;
		auto m_ = m^(e/2); m_ = m_*m_;
		if (e%2 == 1) m_ = m_ * m;
		return m_;
	}
	void multiply_r(int i, T k){
		matrix<T> &m = (*this);
		for (int j = 0; j < col; j++)
			m(i, j) = mult(m(i, j), k);
	}
	void multiply_c(int j, T k){
		matrix<T> &m = (*this);
		for (int i = 0; i < row; j++)
			m(i, j) = mult(m(i, j), k);
	}
	void sum_r(int i1, int i2, T k){
		matrix<T> &m = (*this);
		for (int j = 0; j < col; j++)
			m(i1, j) = sum(m(i1, j), mult(k, m(i2, j)));

	}
	bool gaussian(int I, int J){
		matrix<T> &m = (*this);
		T tmp = m(I, J);
		if (equal(tmp, 0)) return false;
		multiply_r(I, inverse(tmp));
		for (int i = 0; i < row; i++)
			if (i != I) sum_r(i, I, mult(-1, m(i, J)));
		multiply_r(I, tmp);
		return true;
	}
	T determinant(){
		matrix<T> m = (*this);
		for (int i = 0; i < row; i++)
			if (!m.gaussian(i, i)) return 0;	

		T ans = 1;
		for (int i = 0; i < row; i++)
			ans = mult(ans, m(i, i));
		return ans;
	}
};
\end{lstlisting}

\subsection{Primitivas Geometricas}
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

#define sc(a) scanf("%d", &a)
#define sc2(a,b) scanf("%d %d", &a, &b)
#define pri(x) printf("%d\n", x)
#define prie(x) printf("%d ", x)
#define sz(x) (int)((x).size())
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define sq(x) ((x)*(x))
#define BUFF ios::sync_with_stdio(false)

typedef long long int ll;
typedef double ld;
typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ii> vii;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3fll;
const ld DINF = 1e18;
const ld pi = acos(-1.0);
const ld eps = 1e-9;

bool eq(ld a, ld b) {
	return abs(a - b) <= eps;
}

struct pt { // ponto
	ld x, y;
	pt() {}
	pt(ld x, ld y) : x(x), y(y) {}
	bool operator < (const pt p) const {
		if (!eq(x, p.x)) return x < p.x;
		return y < p.y;
	}
	bool operator == (const pt p) const {
		return eq(x, p.x) and eq(y, p.y);
	}
	pt operator + (const pt p) const { return pt(x+p.x, y+p.y); }
	pt operator - (const pt p) const { return pt(x-p.x, y-p.y); }
	pt operator * (const ld c) const { return pt(x*c  , y*c  ); }
	pt operator / (const ld c) const { return pt(x/c  , y/c  ); }
};

struct line { // reta
	pt p, q;
	line() {}
	line(pt p, pt q) : p(p), q(q) {}
};

// PONTO & VETOR

ld dist(pt p, pt q) { // distancia
	return sqrt(sq(p.x - q.x) + sq(p.y - q.y));
}

ld dist2(pt p, pt q) { // quadrado da distancia
	return sq(p.x - q.x) + sq(p.y - q.y);
}

ld norm(pt v) { // norma do vetor
	return dist(pt(0, 0), v);
}

pt normalize(pt v) { // vetor normalizado
	if (!norm(v)) return v;
	v = v / norm(v);
	return v;
}

ld dot(pt u, pt v) { // produto escalar
	return u.x * v.x + u.y * v.y;
}

ld cross(pt u, pt v) { // norma do produto vetorial
	return u.x * v.y - u.y * v.x;
}

ld sarea(pt p, pt q, pt r) { // area com sinal
	return cross(q - p, r - q) / 2;
}

bool col(pt p, pt q, pt r) { // se p, q e r sao colin.
	return eq(sarea(p, q, r), 0);
}

int paral(pt u, pt v) { // se u e v sao paralelos
	u = normalize(u);
	v = normalize(v);
	if (eq(u.x, v.x) and eq(u.y, v.y)) return 1;
	if (eq(u.x, -v.x) and eq(u.y, -v.y)) return -1;
	return 0;
}

bool ccw(pt p, pt q, pt r) { // se p, q, r sao ccw
	return sarea(p, q, r) > 0;
}

pt rotate(pt p, ld th) { // rotaciona o ponto th radianos
	return pt(p.x * cos(th) - p.y * sin(th),
			p.x * sin(th) + p.y * cos(th));
}

pt rotate90(pt p) { // rotaciona 90 graus
	return pt(-p.y, p.x);
}

// RETA

bool isvert(line r) { // se r eh vertical
	return eq(r.p.x, r.q.x);
}

ld getm(line r) { // coef. ang. de r
	if (isvert(r)) return DINF;
	return (r.p.y - r.q.y) / (r.p.x - r.q.x);
}

ld getn(line r) { // coef. lin. de r
	if (isvert(r)) return DINF;
	return r.p.y - getm(r) * r.p.x;
}

bool lineeq(line r, line s) { // r == s
	return col(r.p, r.q, s.p) and col(r.p, r.q, s.q);
}

bool paraline(line r, line s) { // se r e s sao paralelas
	if (isvert(r) and isvert(s)) return 1;
	if (isvert(r) or isvert(s)) return 0;
	return eq(getm(r), getm(s));
}

bool isinline(pt p, line r) { // se p pertence a r
	return col(p, r.p, r.q);
}

bool isinseg(pt p, line r) { // se p pertence ao seg de r
	if (p == r.p or p == r.q) return 1;
	return paral(p - r.p, p - r.q) == -1;
}

pt proj(pt p, line r) { // projecao do ponto p na reta r
	if (r.p == r.q) return r.p;
	r.q = r.q - r.p; p = p - r.p;
	pt proj = r.q * (dot(p, r.q) / dot(r.q, r.q));
	return proj + r.p;
}

pt inter(line r, line s) { // r inter s
	if (paraline(r, s)) return pt(DINF, DINF);

	if (isvert(r)) return pt(r.p.x, getm(s) * r.p.x + getn(s));
	if (isvert(s)) return pt(s.p.x, getm(r) * s.p.x + getn(r));

	ld x = (getn(s) - getn(r)) / (getm(r) - getm(s));
	return pt(x, getm(r) * x + getn(r));
}

bool interseg(line r, line s) { // se o seg de r intercepta o seg de s
	if (paraline(r, s)) {
		return isinseg(r.p, s) or isinseg(r.q, s)
			or isinseg(s.p, r) or isinseg(s.q, r);
	}

	pt i = inter(r, s);
	return isinseg(i, r) and isinseg(i, s);
}

ld disttoline(pt p, line r) { // distancia do ponto a reta
	return dist(p, proj(p, r));
}

ld disttoseg(pt p, line r) { // distancia do ponto ao seg
	if (isinseg(proj(p, r), r))
		return disttoline(p, r);
	return min(dist(p, r.p), dist(p, r.q));
}

ld distseg(line a, line b) { // distancia entre seg
	if (interseg(a, b)) return 0;

	ld ret = DINF;
	ret = min(ret, disttoseg(a.p, b));
	ret = min(ret, disttoseg(a.q, b));
	ret = min(ret, disttoseg(b.p, a));
	ret = min(ret, disttoseg(b.q, a));

	return ret;
}

// POLIGONO

ld polper(vector<pt> v) { // perimetro do poligono
	ld ret = 0;
	for (int i = 0; i < sz(v); i++)
		ret += dist(v[i], v[(i + 1) % sz(v)]);
	return ret;
}

ld polarea(vector<pt> v) { // area do poligono
	ld ret = 0;
	for (int i = 0; i < sz(v); i++)
		ret += sarea(pt(0, 0), v[i], v[(i + 1) % sz(v)]);
	return abs(ret);
}

bool onpol(pt p, vector<pt> v) { // se um ponto esta na fronteira do poligono
	for (int i = 0; i < sz(v); i++)
		if (isinseg(p, line(v[i], v[(i + 1) % sz(v)]))) return 1;
	return 0;
}

bool inpol(pt p, vector<pt> v) { // se um ponto pertence ao poligono
	if (onpol(p, v)) return 1;
	int c = 0;
	line r = line(p, pt(DINF, pi * DINF));
	for (int i = 0; i < sz(v); i++) {
		line s = line(v[i], v[(i + 1) % sz(v)]);
		if (interseg(r, s)) c++;
	}
	return c & 1;
}

bool interpol(vector<pt> v1, vector<pt> v2) { // se dois poligonos se interceptam
	for (int i = 0; i < sz(v1); i++) if (inpol(v1[i], v2)) return 1;
	for (int i = 0; i < sz(v2); i++) if (inpol(v2[i], v1)) return 1;
	return 0;
}

ld distpol(vector<pt> v1, vector<pt> v2) { // distancia entre poligonos
	if (interpol(v1, v2)) return 0;

	ld ret = DINF;

	for (int i = 0; i < sz(v1); i++) for (int j = 0; j < sz(v2); j++)
		ret = min(ret, distseg(line(v1[i], v1[(i + 1) % sz(v1)]),
					line(v2[j], v2[(j + 1) % sz(v2)])));
	return ret;
}

vector<pt> convexhull(vector<pt> v) { // convex hull
	vector<pt> l, u;

	sort(v.begin(), v.end());

	for (int i = 0; i < sz(v); i++) {
		while (sz(l) > 1 and !ccw(v[i], l[sz(l) - 1], l[sz(l) - 2]))
			l.pop_back();
		l.pb(v[i]);
	}
	for (int i = sz(v) - 1; i >= 0; i--) {
		while (sz(u) > 1 and !ccw(v[i], u[sz(u) - 1], u[sz(u) - 2]))
			u.pop_back();
		u.pb(v[i]);
	}

	l.pop_back(); u.pop_back();

	for (int i = 0; i < sz(u); i++) l.pb(u[i]);

	return l;
}

// CIRCULO

pt getcenter(pt a, pt b, pt c) { // centro da circunferencia dado 3 pontos
	b = (a + b) / 2;
	c = (a + c) / 2;
	return inter(line(b, b + rotate90(a - b)),
			line(c, c + rotate90(a - c)));
}


circle minCirc(vector<PT> v) { // minimum enclosing circle
	int n = v.size();
	random_shuffle(v.begin(), v.end());
	PT p = PT(0.0, 0.0);
	circle ret = circle(p, 0.0);
	for(int i = 0; i < n; i++) {
		if(!inside(ret, v[i])) {
			ret = circle(v[i], 0);
			for(int j = 0; j < i; j++) {
				if(!inside(ret, v[j])) {
					ret = circle((v[i] + v[j]) / 2.0, sqrt(dist2(v[i], v[j])) / 2.0);
					for(int k = 0; k < j; k++) {
						if(!inside(ret, v[k])) {
							p = bestOf3(v[i], v[j], v[k]);
							ret = circle(p, sqrt(dist2(p, v[i])));
						}
					}
				}
			}
		}
	}
	return ret;
}

// comparador pro set para fazer sweep angle com segmentos
double ang;
struct cmp {
	bool operator () (const line& a, const line& b) {
		line r = line(pt(0, 0), rotate(pt(1, 0), ang));
		return norm(inter(r, a)) < norm(inter(r, b));
	}
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Grafos
%
%%%%%%%%%%%%%%%%%%%%

\section{Grafos}

\subsection{Dijkstra}
\begin{lstlisting}
// encontra menor distancia de a
// para todos os vertices
// se ao final do algoritmo d[i] = INF,
// entao a nao alcanca i
//
// O(m log(n))

int n;
vector<vector<int> > g(MAX);
vector<vector<int> > w(MAX); // peso das arestas
int d[MAX];

void dijsktra(int a) {
	for (int i = 0; i < n; i++) d[i] = INF;
	d[a] = 0;
	priority_queue<pair<int, int> > Q;
	Q.push(make_pair(0, a));

	while (Q.size()) {
		int u = Q.top().second, dist = -Q.top().first;
		Q.pop();
		if (dist > d[u]) continue;

		for (int i = 0; i < (int) g[u].size(); i++) {
			int v = g[u][i];
			if (d[v] > d[u] + w[u][i]) {
				d[v] = d[u] + w[u][i];
				Q.push(make_pair(-d[v], v));
			}
		}
	}
}
\end{lstlisting}

\subsection{Dinic (Dilson)}
\begin{lstlisting}
// O(n^2 m)
// Grafo bipartido -> O(sqrt(n)*m)

template <class T> struct dinic {
	struct edge {
		int v, rev;
		T cap;
		edge(int v_, T cap_, int rev_) : v(v_), cap(cap_), rev(rev_) {}
	};
	vector<vector<edge>> g;
	vector<int> level;
	queue<int> q;
	T flow;
	int n;
	dinic(int n_) : g(n_), level(n_), n(n_) {}
	void add_edge(int u, int v, T cap) {
		if (u == v)
			return;
		edge e(v, cap, int(g[v].size()));
		edge r(u, 0, int(g[u].size()));
		g[u].push_back(e);
		g[v].push_back(r);
	}

	bool build_level_graph(int src, int sink) {
		fill(level.begin(), level.end(), -1);
		while (not q.empty())
			q.pop();
		level[src] = 0;
		q.push(src);
		while (not q.empty()) {
			int u = q.front();
			q.pop();
			for (auto e = g[u].begin(); e != g[u].end(); ++e) {
				if (not e->cap or level[e->v] != -1)
					continue;
				level[e->v] = level[u] + 1;
				if (e->v == sink)
					return true;
				q.push(e->v);
			}
		}
		return false;
	}

	T blocking_flow(int u, int sink, T f) {
		if (u == sink or not f)
			return f;
		T fu = f;
		for (auto e = g[u].begin(); e != g[u].end(); ++e) {
			if (not e->cap or level[e->v] != level[u] + 1)
				continue;
			T mincap = blocking_flow(e->v, sink, min(fu, e->cap));
			if (mincap) {
				g[e->v][e->rev].cap += mincap;
				e->cap -= mincap;
				fu -= mincap;
			}
		}
		if (f == fu)
			level[u] = -1;
		return f - fu;
	}
	T max_flow(int src, int sink) {
		flow = 0;
		while (build_level_graph(src, sink))
			flow += blocking_flow(src, sink, numeric_limits<T>::max());
		return flow;
	}
};

\end{lstlisting}

\subsection{Centro da Arvore}
\begin{lstlisting}
// Centro eh o vertice que minimiza
// a maior distancia dele pra alguem
// O centro fica no meio do diametro
// A funcao center retorna um par com
// o diametro e o centro
//
// O(n+m)

vector<vector<int> > g(MAX);
int n, vis[MAX];
int d[2][MAX];

// retorna ultimo vertice visitado
int bfs(int k, int x) {
        queue<int> q; q.push(k);
	memset(vis, 0, sizeof(vis));
	vis[k] = 1;
	d[x][k] = 0;
	int last = k;
	
	while (q.size()) {
		int u = q.front(); q.pop();
		last = u;
		for (int i : g[u]) if (!vis[i]) {
			vis[i] = 1;
			q.push(i);
			d[x][i] = d[x][u] + 1;
		}
	}
	return last;
}

pair<int, int> center() {
	int a = bfs(0, 0);
	int b = bfs(a, 1);
	bfs(b, 0);
	int c, mi = INF;
	for (int i = 0; i < n; i++) if (max(d[0][i], d[1][i]) < mi) {
		mi = max(d[0][i], d[1][i]), c = i;
	return {d[0][a], c};
}
\end{lstlisting}

\subsection{Heavy-Light Decomposition - aresta}
\begin{lstlisting}
// SegTree de soma
// query / update de soma das arestas
//
// Complexidades:
// build - O(n)
// query_path - O(log^2 (n))
// update_path - O(log^2 (n))
// query_subtree - O(log(n))
// update_subtree - O(log(n))

#define f first
#define s second

namespace seg {
	ll seg[4*MAX], lazy[4*MAX];
	int n, *v;

	ll build(int p=1, int l=0, int r=n-1) {
		lazy[p] = 0;
		if (l == r) return seg[p] = v[l];
		int m = (l+r)/2;
		return seg[p] = build(2*p, l, m) + build(2*p+1, m+1, r);
	}
	void build(int n2, int* v2) {
		n = n2, v = v2;
		build();
	}
	void prop(int p, int l, int r) {
		seg[p] += lazy[p]*(r-l+1);
		if (l != r) lazy[2*p] += lazy[p], lazy[2*p+1] += lazy[p];
		lazy[p] = 0;
	}
	ll query(int a, int b, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) return seg[p];
		if (b < l or r < a) return 0;
		int m = (l+r)/2;
		return query(a, b, 2*p, l, m) + query(a, b, 2*p+1, m+1, r);
	}
	ll update(int a, int b, int x, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) {
			lazy[p] += x;
			prop(p, l, r);
			return seg[p];
		}
		if (b < l or r < a) return seg[p];
		int m = (l+r)/2;
		return seg[p] = update(a, b, x, 2*p, l, m) +
			update(a, b, x, 2*p+1, m+1, r);
	}
};

namespace hld {
	vector<pair<int, int> > g[MAX];
	int in[MAX], out[MAX], sz[MAX];
	int sobe[MAX], pai[MAX];
	int h[MAX], v[MAX], t;

	void build_hld(int k, int p = -1, int f = 1) {
		v[in[k] = t++] = sobe[k]; sz[k] = 1;
		for (auto& i : g[k]) if (i.f != p) {
			sobe[i.f] = i.s; pai[i.f] = k;
			h[i.f] = (i == g[k][0] ? h[k] : i.f);
			build_hld(i.f, k, f); sz[k] += sz[i.f];

			if (sz[i.f] > sz[g[k][0].f]) swap(i, g[k][0]);
		}
		out[k] = t;
		if (p*f == -1) build_hld(h[k] = k, -1, t = 0);
	}
	void build(int root = 0) {
		t = 0;
		build_hld(root);
		seg::build(t, v);
	}
	ll query_path(int a, int b) {
		if (a == b) return 0;
		if (in[a] < in[b]) swap(a, b);

		if (h[a] == h[b]) return seg::query(in[b]+1, in[a]);
		return seg::query(in[h[a]], in[a]) + query_path(pai[h[a]], b);
	}
	void update_path(int a, int b, int x) {
		if (a == b) return;
		if (in[a] < in[b]) swap(a, b);

		if (h[a] == h[b]) return (void)seg::update(in[b]+1, in[a], x);
		seg::update(in[h[a]], in[a], x); update_path(pai[h[a]], b, x);
	}
	ll query_subtree(int a) {
		if (in[a] == out[a]-1) return 0;
		return seg::query(in[a]+1, out[a]-1);
	}
	void update_subtree(int a, int x) {
		if (in[a] == out[a]-1) return;
		seg::update(in[a]+1, out[a]-1, x);
	}
	int lca(int a, int b) {
		if (in[a] < in[b]) swap(a, b);
		return h[a] == h[b] ? b : lca(pai[h[a]], b);
	}
};
\end{lstlisting}

\subsection{Heavy-Light Decomposition sem Update}
\begin{lstlisting}
// query de min do caminho
//
// Complexidades:
// build - O(n)
// query_path - O(log(n))

#define f first
#define s second

namespace hld {
	vector<pair<int, int> > g[MAX];
	int in[MAX], sz[MAX];
	int sobe[MAX], pai[MAX];
	int h[MAX], v[MAX], t;
	int men[MAX], seg[2*MAX];

	void build_hld(int k, int p = -1, int f = 1) {
		v[in[k] = t++] = sobe[k]; sz[k] = 1;
		for (auto& i : g[k]) if (i.f != p) {
			sobe[i.f] = i.s; pai[i.f] = k;
			h[i.f] = (i == g[k][0] ? h[k] : i.f);
			men[i.f] = (i == g[k][0] ? min(men[k], i.s) : i.s);
			build_hld(i.f, k, f); sz[k] += sz[i.f];

			if (sz[i.f] > sz[g[k][0].f]) swap(i, g[k][0]);
		}
		if (p*f == -1) build_hld(h[k] = k, -1, t = 0);
	}
	void build(int root = 0) {
		t = 0;
		build_hld(root);
		for (int i = 0; i < t; i++) seg[i+t] = v[i];
		for (int i = t-1; i; i--) seg[i] = min(seg[2*i], seg[2*i+1]);
	}
	int query_path(int a, int b) {
		if (a == b) return INF;
		if (in[a] < in[b]) swap(a, b);

		if (h[a] != h[b]) return min(men[a], query_path(pai[h[a]], b));
		int ans = INF, x = in[b]+1+t, y = in[a]+t;
		for (; x <= y; ++x/=2, --y/=2) ans = min({ans, seg[x], seg[y]});
		return ans;
	}
};
\end{lstlisting}

\subsection{LCA com RMQ}
\begin{lstlisting}
// Assume que um vertice eh ancestral dele mesmo, ou seja,
// se a eh ancestral de b, lca(a, b) = a
//
// Complexidades:
// build - O(n) + build_RMQ
// lca - RMQ
 
int n;
vector<vector<int> > g(MAX);
int pos[MAX];     // pos[i] : posicao de i em v (primeira aparicao
int ord[2 * MAX]; // ord[i] : i-esimo vertice na ordem de visitacao da dfs
int v[2 * MAX];   // vetor de alturas que eh usado na RMQ
int p;
 
void dfs(int k, int l) {
	ord[p] = k;
	pos[k] = p;
	v[p++] = l;
	for (int i = 0; i < (int) g[k].size(); i++)
		if (pos[g[k][i]] == -1) {
			dfs(g[k][i], l + 1);
			ord[p] = k;
			v[p++] = l;
		}
}
 
void build(int root) {
	for (int i = 0; i < n; i++) pos[i] = -1;

	p = 0;
	dfs(root, 0);

	build_RMQ();
}
 
int lca(int u, int v) {
	int a = pos[u], b = pos[v];
	if (a > b) swap(a, b);
	return ord[RMQ(a, b)];
}
\end{lstlisting}

\subsection{Heavy-Light Decomposition - vertice}
\begin{lstlisting}
// SegTree de soma
// query / update de soma dos vertices
//
// Complexidades:
// build - O(n)
// query_path - O(log^2 (n))
// update_path - O(log^2 (n))
// query_subtree - O(log(n))
// update_subtree - O(log(n))

namespace seg {
	ll seg[4*MAX], lazy[4*MAX];
	int n, *v;

	ll build(int p=1, int l=0, int r=n-1) {
		lazy[p] = 0;
		if (l == r) return seg[p] = v[l];
		int m = (l+r)/2;
		return seg[p] = build(2*p, l, m) + build(2*p+1, m+1, r);
	}
	void build(int n2, int* v2) {
		n = n2, v = v2;
		build();
	}
	void prop(int p, int l, int r) {
		seg[p] += lazy[p]*(r-l+1);
		if (l != r) lazy[2*p] += lazy[p], lazy[2*p+1] += lazy[p];
		lazy[p] = 0;
	}
	ll query(int a, int b, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) return seg[p];
		if (b < l or r < a) return 0;
		int m = (l+r)/2;
		return query(a, b, 2*p, l, m) + query(a, b, 2*p+1, m+1, r);
	}
	ll update(int a, int b, int x, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) {
			lazy[p] += x;
			prop(p, l, r);
			return seg[p];
		}
		if (b < l or r < a) return seg[p];
		int m = (l+r)/2;
		return seg[p] = update(a, b, x, 2*p, l, m) +
			update(a, b, x, 2*p+1, m+1, r);
	}
};

namespace hld {
	vector<int> g[MAX];
	int in[MAX], out[MAX], sz[MAX];
	int peso[MAX], pai[MAX];
	int h[MAX], v[MAX], t;

	void build_hld(int k, int p = -1, int f = 1) {
		v[in[k] = t++] = peso[k]; sz[k] = 1;
		for (auto& i : g[k]) if (i != p) {
			pai[i] = k;
			h[i] = (i == g[k][0] ? h[k] : i);
			build_hld(i, k, f); sz[k] += sz[i];

			if (sz[i] > sz[g[k][0]]) swap(i, g[k][0]);
		}
		out[k] = t;
		if (p*f == -1) build_hld(h[k] = k, -1, t = 0);
	}
	void build(int root = 0) {
		t = 0;
		build_hld(root);
		seg::build(t, v);
	}
	ll query_path(int a, int b) {
		if (a == b) return seg::query(in[a], in[a]);
		if (in[a] < in[b]) swap(a, b);

		if (h[a] == h[b]) return seg::query(in[b], in[a]);
		return seg::query(in[h[a]], in[a]) + query_path(pai[h[a]], b);
	}
	void update_path(int a, int b, int x) {
		if (a == b) return (void)seg::update(in[a], in[a], x);
		if (in[a] < in[b]) swap(a, b);

		if (h[a] == h[b]) return (void)seg::update(in[b], in[a], x);
		seg::update(in[h[a]], in[a], x); update_path(pai[h[a]], b, x);
	}
	ll query_subtree(int a) {
		if (in[a] == out[a]-1) return seg::query(in[a], in[a]);
		return seg::query(in[a], out[a]-1);
	}
	void update_subtree(int a, int x) {
		if (in[a] == out[a]-1) return (void)seg::update(in[a], in[a], x);
		seg::update(in[a], out[a]-1, x);
	}
	int lca(int a, int b) {
		if (in[a] < in[b]) swap(a, b);
		return h[a] == h[b] ? b : lca(pai[h[a]], b);
	}
};
\end{lstlisting}

\subsection{LCA com HLD}
\begin{lstlisting}
// Assume que um vertice eh ancestral dele mesmo, ou seja,
// se a eh ancestral de b, lca(a, b) = a
// Para buildar pasta chamar build(root)
//
// Complexidades:
// build - O(n)
// lca - O(log(n))

vector<vector<int> > g(MAX);
int in[MAX], h[MAX], sz[MAX];
int pai[MAX], t;

void build(int k, int p = -1, int f = 1) {
	in[k] = t++; sz[k] = 1;
	for (int& i : g[k]) if (i != p) {
		pai[i] = k;
		h[i] = (i == g[k][0] ? h[k] : i);
		build(i, k, f); sz[k] += sz[i];
		
		if (sz[i] > sz[g[k][0]]) swap(i, g[k][0]);
	}
	if (p*f == -1) t = 0, h[k] = k, build(k, -1, 0);
}

int lca(int a, int b) {
	if (in[a] < in[b]) swap(a, b);
	return h[a] == h[b] ? b : lca(pai[h[a]], b);
}
\end{lstlisting}

\subsection{LCA com binary lifting}
\begin{lstlisting}
// Assume que um vertice eh ancestral dele mesmo, ou seja,
// se a eh ancestral de b, lca(a, b) = a
// MAX2 = ceil(log(MAX))
//
// Complexidades:
// build - O(n log(n))
// lca - O(log(n))

vector<vector<int> > g(MAX);
int n, p;
int pai[MAX2][MAX];
int in[MAX], out[MAX];

void dfs(int k) {
	in[k] = p++;
	for (int i = 0; i < (int) g[k].size(); i++)
		if (in[g[k][i]] == -1) {
			pai[0][g[k][i]] = k;
			dfs(g[k][i]);
		}
	out[k] = p++;
}

void build(int raiz) {
	for (int i = 0; i < n; i++) pai[0][i] = i;
	p = 0, memset(in, -1, sizeof in);
	dfs(raiz);

	// pd dos pais
	for (int k = 1; k < MAX2; k++) for (int i = 0; i < n; i++)
		pai[k][i] = pai[k - 1][pai[k - 1][i]];
}

bool anc(int a, int b) { // se a eh ancestral de b
	return in[a] <= in[b] and out[a] >= out[b];
}

int lca(int a, int b) {
	if (anc(a, b)) return a;
	if (anc(b, a)) return b;

	// sobe a
	for (int k = MAX2 - 1; k >= 0; k--)
		if (!anc(pai[k][a], b)) a = pai[k][a];

	return pai[0][a];
}
\end{lstlisting}

\subsection{2-SAT}
\begin{lstlisting}
// Retorna se eh possivel atribuir valores
// Grafo tem que caber 2n vertices
// add(x, y) adiciona implicacao x -> y
// Para adicionar uma clausula (x ou y)
// chamar add(nao(x), y)
// Se x tem que ser verdadeiro, chamar add(nao(x), x)
// O tarjan deve computar o componente conexo
// de cada vertice em comp
//
// O(|V|+|E|)

vector<vector<int> > g(MAX);
int n;

int nao(int x){ return (x + n) % (2*n); }

// x -> y  =  !x ou y
void add(int x, int y){
	g[x].pb(y);
	// contraposicao
	g[nao(y)].pb(nao(x));
}

bool doisSAT(){
	tarjan();
	for (int i = 0; i < m; i++)
		if (comp[i] == comp[nao(i)]) return 0;
	return 1;
}
\end{lstlisting}

\subsection{Dinic (Bruno)}
\begin{lstlisting}
// O(n^2 m)
// Grafo com capacidades 1 -> O(sqrt(n)*m)

struct dinic{
	struct edge {
		int p, c, id; // para, capacidade, id
		edge(int p_, int c_, int id_) : p(p_), c(c_), id(id_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev;
	dinic(int n): g(n){}
	void add(int a, int b, int c) { // de a pra b com cap. c
		g[a].pb(edge(b, c, g[b].size()));
		g[b].pb(edge(a, 0, g[a].size()-1));
	}

	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.p] != -1 or !i.c) continue;
				lev[i.p] = lev[u] + 1;
				if (i.p == t) return 1;
				q.push(i.p);
			}
		}
		return 0;
	}

	int dfs(int v, int s, int f = INF){
		if (v == s) return f;
		int tem = f;
		for (auto& i : g[v]) {
			if (lev[i.p] != lev[v] + 1 or !i.c) continue;
			int foi = dfs(i.p, s, min(tem, i.c));
			tem -= foi, i.c -= foi, g[i.p][i.id].c += foi;
		}
		if (f == tem) lev[v] = -1;
		return f - tem;
	}

	int max_flow(int s, int t) {
		int f = 0;
		while (bfs(s, t)) f += dfs(s, t);
		return f;
	}
};


\end{lstlisting}

\subsection{Max flow com lower bound}
\begin{lstlisting}
// Manda passar pelo menos 'lb' de fluxo
// em cada aresta
//
// O(dinic)

struct lb_max_flow : dinic {
	vector<int> d;
	vector<int> e;
	lb_max_flow(int n):dinic(n + 2), d(n, 0){}
	void add(int a, int b, int c, int lb = 0){
		c -= lb;
		d[a] -= lb;
		d[b] += lb;
		dinic::add(a, b, c);
	}
	bool check_flow(int src, int snk, int F){
		int n = d.size();
		d[src] += F;
		d[snk] -= F;

		for (int i = 0; i < n; i++){
			if (d[i] > 0){
				dinic::add(n, i, d[i]);
			} else if (d[i] < 0){
				dinic::add(i, n+1, -d[i]);
			}
		}

		int f = max_flow(n, n+1);
		return (f == F);
	}
};
\end{lstlisting}

\subsection{Floyd-Warshall}
\begin{lstlisting}
// encontra o menor caminho entre todo
// par de vertices e detecta ciclo negativo
// returna 1 sse ha ciclo negativo
// d[i][i] deve ser 0
// para i != j, d[i][j] deve ser w se ha uma aresta
// (i, j) de peso w, INF caso contrario
//
// O(n^3)

int n;
int d[MAX][MAX];

bool floyd_warshall() {
	for (int k = 0; k < n; k++)
	for (int i = 0; i < n; i++)
	for (int j = 0; j < n; j++)
		d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

	for (int i = 0; i < n; i++)
		if (d[i][i] < 0) return 1;

	return 0;
}
\end{lstlisting}

\subsection{Blossom - matching maximo em grafo geral}
\begin{lstlisting}
// O(n^3)
// Se for bipartido, nao precisa da funcao
// 'contract', e roda em O(nm)

vector<vector<int> > g(MAX);
int match[MAX]; // match[i] = com quem i esta matchzado ou -1
int n, pai[MAX], base[MAX], vis[MAX];
queue<int> q;
 
void contract(int u, int v, bool first = 1) {
    static vector<bool> bloss;
    static int l;
    if (first) {
        bloss = vector<bool>(n, 0);
        vector<bool> teve(n, 0);
        int k = u; l = v;
        while (1) {
            teve[k = base[k]] = 1;
            if (match[k] == -1) break;
            k = pai[match[k]];
        }
        while (!teve[l = base[l]]) l = pai[match[l]];
    }
    while (base[u] != l) {
        bloss[base[u]] = bloss[base[match[u]]] = 1;
        pai[u] = v;
        v = match[u];
        u = pai[match[u]];
    }
    if (!first) return;
    contract(v, u, 0);
    for (int i = 0; i < n; i++) if (bloss[base[i]]) {
        base[i] = l;
        if (!vis[i]) q.push(i);
        vis[i] = 1;
    }
}
 
int getpath(int s) {
    for (int i = 0; i < n; i++) base[i] = i, pai[i] = -1, vis[i] = 0;
    vis[s] = 1; q = queue<int>(); q.push(s);
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int i : g[u]) {
            if (base[i] == base[u] or match[u] == i) continue;
            if (i == s or (match[i] != -1 and pai[match[i]] != -1))
                contract(u, i);
            else if (pai[i] == -1) {
                pai[i] = u;
                if (match[i] == -1) return i;
                i = match[i];
                vis[i] = 1; q.push(i);
            }
        }
    }
    return -1;
}
 
int blossom() {
    int ans = 0;
    memset(match, -1, sizeof(match));
    for (int i = 0; i < n; i++) if (match[i] == -1)
        for (int j : g[i]) if (match[j] == -1) {
            match[i] = j;
            match[j] = i;
            ans++;
            break;
        }
    for (int i = 0; i < n; i++) if (match[i] == -1) {
        int j = getpath(i);
        if (j == -1) continue;
        ans++;
        while (j != -1) {
            int p = pai[j], pp = match[p];
            match[p] = j;
            match[j] = p;
            j = pp;
        }
    }
    return ans;
}
\end{lstlisting}

\subsection{MinCostMaxFlow Papa}
\begin{lstlisting}
/*
   s e t pre-definidos como MAXN - 1 e MAXN - 2.
   minCostFlow(f) computa o par (fluxo, custo) com max(fluxo) <= f que tenha min(custo).
   minCostFlow(INF) -> Fluxo maximo de custo minimo.
   Se tomar TLE, aleatorizar a ordem dos vertices no SPFA
 */

const int MAXN = 230;

template<typename T> struct MCMF {
	
	struct edge {
		int to, rev, flow, cap, residual;
		T cost;
		edge() { to = 0; rev = 0; flow = 0; cap = 0; cost = 0; residual = false; }
		edge(int _to, int _rev, int _flow, int _cap, T _cost, bool _residual) {
			to = _to; rev = _rev;
			flow = _flow; cap = _cap;
			cost = _cost;
			residual = _residual;
		}
	};

	int s = MAXN - 1, t = MAXN - 2;
	vector<edge> G[MAXN];

	void addEdge(int u, int v, int w, T cost) {
		edge t = edge(v, G[v].size(), 0, w, cost, false);
		edge r = edge(u, G[u].size(), 0, 0, -cost, true);

		G[u].push_back(t);
		G[v].push_back(r);
	}

	deque<int> Q;
	bool is_inside[MAXN];
	int par_idx[MAXN], par[MAXN];
	T dist[MAXN];
	bool spfa() {
		for(int i = 0; i < MAXN; i++)
			dist[i] = INF;
		dist[t] = INF;

		Q.clear();
		dist[s] = 0;
		is_inside[s] = true;
		Q.push_back(s);

		while(!Q.empty()) {
			int u = Q.front();
			is_inside[u] = false;
			Q.pop_front();

			for(int i = 0; i < (int)G[u].size(); i++)
				if(G[u][i].cap > G[u][i].flow && dist[u] + G[u][i].cost < dist[G[u][i].to]) {
					dist[G[u][i].to] = dist[u] + G[u][i].cost;
					par_idx[G[u][i].to] = i;
					par[G[u][i].to] = u;

					if(is_inside[G[u][i].to]) continue;
					if(!Q.empty() && dist[G[u][i].to] > dist[Q.front()]) Q.push_back(G[u][i].to);
					else Q.push_front(G[u][i].to);

					is_inside[G[u][i].to] = true;
				}
		}

		return dist[t] != INF;
	}

	pair<int, T>  minCostFlow(int flow) {
		int f = 0;
		T ret = 0;
		while(f <= flow && spfa()) {
			int mn_flow = flow - f, u = t;
			while(u != s){
				mn_flow = min(mn_flow, G[par[u]][par_idx[u]].cap - G[par[u]][par_idx[u]].flow);
				u = par[u];
			}

			u = t;
			while(u != s) {
				G[par[u]][par_idx[u]].flow += mn_flow;
				G[u][G[par[u]][par_idx[u]].rev].flow -= mn_flow;
				ret += G[par[u]][par_idx[u]].cost * mn_flow;
				u = par[u];
			}

			f += mn_flow;
		}

		return make_pair(f, ret);
	}

	/*
	   Opcional.
	   Retorna todas as arestas originais por onde passa fluxo = capacidade.
	 */
	vector<pair<int ,int > > recover() {
		vector<pair<int, int > > used;
		for(int i = 0; i < MAXN; i++) 
			for(edge e : G[i])
				if(e.flow == e.cap && !e.residual)
					used.push_back({i, e.to});
		return used;
	}
};
\end{lstlisting}

\subsection{Kruskal}
\begin{lstlisting}
// Gera AGM a partir do vetor de arestas
//
// O(m log(n))

int n;
vector<pair<int, pair<int, int> > > ar; // vetor de arestas
int v[MAX];

// Union-Find em O(log(n))
void build();
int find(int k);
void une(int a, int b);

void kruskal() {
	build();

	sort(ar.begin(), ar.end());
	for (int i = 0; i < (int) ar.size(); i++) {
		int a = ar[i].s.f, b = ar[i].s.s;
		if (find(a) != find(b)) {
			une(a, b);
			// aresta faz parte da AGM
		}
	}
}
\end{lstlisting}

\subsection{Centroid decomposition}
\begin{lstlisting}
// O(n log(n))

int n;
vector<vector<int> > g(MAX);
int subsize[MAX];
int rem[MAX];
int pai[MAX];

void dfs(int k, int last) {
	subsize[k] = 1;
	for (int i = 0; i < (int) g[k].size(); i++)
		if (g[k][i] != last and !rem[g[k][i]]) {
			dfs(g[k][i], k);
			subsize[k] += subsize[g[k][i]];
		}
}

int centroid(int k, int last, int size) {
	for (int i = 0; i < (int) g[k].size(); i++) {
		int u = g[k][i];
		if (rem[u] or u == last) continue;
		if (subsize[u] > size / 2)
			return centroid(u, k, size);
	}
	// k eh o centroid
	return k;
}

void decomp(int k, int last) {
	dfs(k, k);

	// acha e tira o centroid
	int c = centroid(k, k, subsize[k]);
	rem[c] = 1;
	pai[c] = last;
	if (k == last) pai[c] = c;

	// decompoe as sub-arvores
	for (int i = 0; i < (int) g[c].size(); i++)
		if (!rem[g[c][i]]) decomp(g[c][i], c);
}

void build() {
	memset(rem, 0, sizeof rem);
	decomp(0, 0);
}
\end{lstlisting}

\subsection{Kosaraju}
\begin{lstlisting}
// O(n + m)

int n;
vector<vector<int> > g(MAX);
vector<vector<int> > gi(MAX); // grafo invertido
int vis[MAX];
stack<int> S;
int comp[MAX]; // componente conexo de cada vertice

void dfs(int k) {
	vis[k] = 1;
	for (int i = 0; i < (int) g[k].size(); i++)
		if (!vis[g[k][i]]) dfs(g[k][i]);

	S.push(k);
}

void scc(int k, int c) {
	vis[k] = 1;
	comp[k] = c;
	for (int i = 0; i < (int) gi[k].size(); i++)
		if (!vis[gi[k][i]]) scc(gi[k][i], c);
}

void kosaraju() {
	for (int i = 0; i < n; i++) vis[i] = 0;
	for (int i = 0; i < n; i++) if (!vis[i]) dfs(i);

	for (int i = 0; i < n; i++) vis[i] = 0;
	while (S.size()) {
		int u = S.top();
		S.pop();
		if (!vis[u]) scc(u, u);
	}
}
\end{lstlisting}

\subsection{Bellman-Ford}
\begin{lstlisting}
// Calcula a menor distancia
// entre a e todos os vertices e
// detecta ciclo negativo
// Retorna 1 se ha ciclo negativo
// Nao precisa representar o grafo,
// soh armazenar as arestas
//
// O(nm)

int n, m;
int d[MAX];
vector<pair<int, int> > ar; // vetor de arestas
vector<int> w;              // peso das arestas

bool bellman_ford(int a) {
	for (int i = 0; i < n; i++) d[i] = INF;
	d[a] = 0;

	for (int i = 0; i <= n; i++)
		for (int j = 0; j < m; j++) {
			if (d[ar[j].second] > d[ar[j].first] + w[j]) {
				if (i == n) return 1;

				d[ar[j].second] = d[ar[j].first] + w[j];
			}
		}

	return 0;
}
\end{lstlisting}

\subsection{Isomorfismo de Arvores}
\begin{lstlisting}
// Duas arvores T1 e T2 sao isomorfas
// sse T1.getHash() = T2.getHash()
//
// O(n log(n))

map<vector<int>, int> mapp;

struct tree {
	int n;
	vector<vector<int> > g;
	vector<int> subsize;

	tree(int n) {
		g.resize(n);
		subsize.resize(n);
	}
	void dfs(int k, int p=-1) {
		subsize[k] = 1;
		for (int i : g[k]) if (i != p) {
			dfs(i, k);
			subsize[k] += subsize[i];
		}
	}
	int centroid(int k, int p=-1, int size=-1) {
		if (size == -1) size = subsize[k];
		for (int i : g[k]) if (i != p)
			if (subsize[i] > size/2)
				return centroid(i, k, size);
		return k;
	}
	pair<int, int> centroids(int k=0) {
		dfs(k);
		int i = centroid(k), i2 = i;
		for (int j : g[i]) if (2*subsize[j] == subsize[k]) i2 = j;
		return {i, i2};
	}
	int hashh(int k, int p=-1) {
		vector<int> v;
		for (int i : g[k]) if (i != p) v.push_back(hashh(i, k));
		sort(v.begin(), v.end());
		if (!mapp.count(v)) mapp[v] = int(mapp.size());
		return mapp[v];
	}
	ll getHash(int k=0) {
		pair<int, int> c = centroids(k);
		ll a = hashh(c.first), b = hashh(c.second);
		if (a > b) swap(a, b);
		return (a<<30)+b;
	}
};
\end{lstlisting}

\subsection{Tarjan para SCC}
\begin{lstlisting}
// O(n + m)

int n;
vector<vector<int> > g(MAX);
stack<int> s;
int vis[MAX], comp[MAX];
int id[MAX], p;

int dfs(int k) {
	int lo = id[k] = p++;
	s.push(k);
	vis[k] = 2; // ta na pilha

	// calcula o menor cara q ele alcanca
	// que ainda nao esta em um scc
	for (int i = 0; i < g[k].size(); i++) {
	 	if (!vis[g[k][i]])
			lo = min(lo, dfs(g[k][i]));
		else if (vis[g[k][i]] == 2)
			lo = min(lo, id[g[k][i]]);
	}

	// nao alcanca ninguem menor -> comeca scc
	if (lo == id[k]) while (1) {
		int u = s.top();
		s.pop(); vis[u] = 1;
		comp[u] = k;
		if (u == k) break;
	}

	return lo;
}

void tarjan() {
	memset(vis, 0, sizeof(vis));

	p = 0;
	for (int i = 0; i < n; i++) if (!vis[i]) dfs(i);
}
\end{lstlisting}

\subsection{Dominator Tree - Kawakami}
\begin{lstlisting}
// Se vira pra usar ai
//
// build - O(n)
// dominates - O(1)

int n;

namespace DTree {
    vector<int> g[MAX];

    // The dominator tree
    vector<int> tree[MAX];
	int dfs_l[MAX], dfs_r[MAX];

    // Auxiliary data
    vector<int> rg[MAX], bucket[MAX];
	int idom[MAX], sdom[MAX], prv[MAX], pre[MAX];
	int ancestor[MAX], label[MAX];
	vector<int> preorder;

    void dfs(int v) {
        static int t = 0;
        pre[v] = ++t;
        sdom[v] = label[v] = v;
        preorder.push_back(v);
        for (int nxt: g[v]) {
            if (sdom[nxt] == -1) {
                prv[nxt] = v;
                dfs(nxt);
            }
			rg[nxt].push_back(v);
        }
    }
    int eval(int v) {
        if (ancestor[v] == -1) return v;
        if (ancestor[ancestor[v]] == -1) return label[v];
        int u = eval(ancestor[v]);
        if (pre[sdom[u]] < pre[sdom[label[v]]]) label[v] = u;
        ancestor[v] = ancestor[u];
        return label[v];
    }
    void dfs2(int v) {
        static int t = 0;
        dfs_l[v] = t++;
        for (int nxt: tree[v]) dfs2(nxt);
        dfs_r[v] = t++;
    }
	void build(int s) {
		for (int i = 0; i < n; i++) {
			sdom[i] = pre[i] = ancestor[i] = -1;
			rg[i].clear();
			tree[i].clear();
			bucket[i].clear();
		}
		preorder.clear();
        dfs(s);
        if (preorder.size() == 1) return;
        for (int i = int(preorder.size()) - 1; i >= 1; i--) {
            int w = preorder[i];
            for (int v: rg[w]) {
                int u = eval(v);
                if (pre[sdom[u]] < pre[sdom[w]]) sdom[w] = sdom[u];
            }
            bucket[sdom[w]].push_back(w);
			ancestor[w] = prv[w];
            for (int v: bucket[prv[w]]) {
                int u = eval(v);
                idom[v] = (u == v) ? sdom[v] : u;
            }
            bucket[prv[w]].clear();
        }
        for (int i = 1; i < preorder.size(); i++) {
            int w = preorder[i];
            if (idom[w] != sdom[w]) idom[w] = idom[idom[w]];
			tree[idom[w]].push_back(w);
        }
        idom[s] = sdom[s] = -1;
        dfs2(s);
    }

    // Whether every path from s to v passes through u
    bool dominates(int u, int v) {
        if (pre[v] == -1) return 1; // vacuously true
        return dfs_l[u] <= dfs_l[v] && dfs_r[v] <= dfs_r[u];
    }
};
\end{lstlisting}

\subsection{Sack (DSU em arvores)}
\begin{lstlisting}
// Responde queries de todas as sub-arvores
// offline
//
// O(n log(n))

int sz[MAX], cor[MAX], cnt[MAX];
vector<vector<int> > g(MAX);
 
void build(int k, int d=0) {
	sz[k] = 1;
	for (auto& i : g[k]) {
		build(i, d+1); sz[k] += sz[i];
		if (sz[i] > sz[g[k][0]]) swap(i, g[k][0]);
	}
}
 
void compute(int k, int x, bool dont=1) {
	cnt[cor[k]] += x;
	for (int i = dont; i < g[k].size(); i++)
		compute(g[k][i], x, 0);
}
 
void solve(int k, bool keep=0) {
	for (int i = int(g[k].size())-1; i >= 0; i--)
		solve(g[k][i], !i);
	compute(k, 1);
	
        // agora cnt[i] tem quantas vezes a cor
        // i aparece na sub-arvore do k
        
	if (!keep) compute(k, -1, 0);
}
\end{lstlisting}

\subsection{Centroid}
\begin{lstlisting}
// Computa os 2 centroids da arvore
//
// O(n)

int n;
vector<vector<int> > g(MAX);
int subsize[MAX];

void dfs(int k, int p=-1) {
	subsize[k] = 1;
	for (int i : g[k]) if (i != p) {
		dfs(i, k);
		subsize[k] += subsize[i];
	}
}

int centroid(int k, int p=-1, int size=-1) {
	if (size == -1) size = subsize[k];
	for (int i : g[k]) if (i != p and i != rem)
		if (subsize[i] > size/2)
			return centroid(i, k, size, t);
	return k;
}

pair<int, int> centroids(int k=0) {
	dfs(k);
	int i = centroid(k), i2 = i;
	for (int j : g[i]) if (2*subsize[j] == subsize[k]) i2 = j;
	return {i, i2};
}
\end{lstlisting}

\subsection{Tarjan para Pontes}
\begin{lstlisting}
// Computa pontos de articulacao
// e pontes
//
// O(n+m)

int in[MAX];
int low[MAX];
int parent[MAX];
vector<int> g[MAX];

bool is_art[MAX];

void dfs_art(int v, int p, int &d){
	parent[v] = p;
	low[v] = in[v] = d++;
	is_art[v] = false;
	for (int j : g[v]){
		if (j == p) continue;
		if (in[j] == -1){
			dfs_art(j, v, d);

			if (low[j] >= in[v]) is_art[v] = true;
			//if (low[j] >  in[v]) this edge is a bridge

			low[v] = min(low[v], low[j]);
		}
		else low[v] = min(low[v], in[j]);
	}
	if (p == -1){
		is_art[v] = false;
		int k = 0;
		for (int j : g[v])
			k += (parent[j] == v);
		if (k > 1) is_art[v] = true;
	}
}

int d = 0;
memset(in, -1, sizeof in);
dfs_art(1, -1, d);
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Problemas
%
%%%%%%%%%%%%%%%%%%%%

\section{Problemas}

\subsection{Mininum Enclosing Circle}
\begin{lstlisting}
// O(n) com alta probabilidade

const double EPS = 1e-12;
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());

struct pt {
	double x, y;
	pt(double x_ = 0, double y_ = 0) : x(x_), y(y_) {}
	pt operator + (const pt& p) const { return pt(x+p.x, y+p.y); }
	pt operator - (const pt& p) const { return pt(x-p.x, y-p.y); }
	pt operator * (double c) const { return pt(x*c, y*c); }
	pt operator / (double c) const { return pt(x/c, y/c); }
};

double dot(pt p, pt q) { return p.x*q.x+p.y*q.y; }
double cross(pt p, pt q) { return p.x*q.y-p.y*q.x; }
double dist(pt p, pt q) { return sqrt(dot(p-q, p-q)); }

pt center(pt p, pt q, pt r) {
	pt a = p-r, b = q-r;
	pt c = pt(dot(a, p+r)/2, dot(b, q+r)/2);
	return pt(cross(c, pt(a.y, b.y)), cross(pt(a.x, b.x), c)) / cross(a, b);
}

struct circle {
	pt cen;
	double r;
	circle(pt cen_, double r_) : cen(cen_), r(r_) {}
	circle(pt a, pt b, pt c) {
		cen = center(a, b, c);
		r = dist(cen, a);
	}
	bool inside(pt p) { return dist(p, cen) < r+EPS; }
};

circle minCirc(vector<pt> v) {
	shuffle(v.begin(), v.end(), rng);
	circle ret = circle(pt(0, 0), 0);
	for (int i = 0; i < v.size(); i++) if (!ret.inside(v[i])) {
		ret = circle(v[i], 0);
		for (int j = 0; j < i; j++) if (!ret.inside(v[j])) {
			ret = circle((v[i]+v[j])/2, dist(v[i], v[j])/2);
			for (int k = 0; k < j; k++) if (!ret.inside(v[k]))
				ret = circle(v[i], v[j], v[k]);
		}
	}
	return ret;
}

\end{lstlisting}

\subsection{LIS2}
\begin{lstlisting}
// O(n log(n))

template<typename T> int lis(vector<T> &v){
	vector<T> ans;
	for (T t : v){
		auto it = upper_bound(ans.begin(), ans.end(), t);
		if (it == ans.end()) ans.push_back(t);
		else *it = t;
	}
	return ans.size()
}
\end{lstlisting}

\subsection{Points Inside Polygon}
\begin{lstlisting}
// Encontra quais pontos estao
// dentro de um poligono simples nao convexo
// o poligono tem lados paralelos aos eixos
// Pontos na borda estao dentro
// Pontos podem estar em ordem horaria ou anti-horaria
//
// O(n log(n))

#define f first
#define s second
#define pb push_back

typedef long long ll;
typedef pair<int, int> ii;

const ll N = 1e9+10;
const int MAX = 1e5+10;
int ta[MAX];

namespace seg {
	unordered_map<ll, int> seg;
	int query(int a, int b, ll p, ll l, ll r) {
		if (b < l or r < a) return 0;
		if (a <= l and r <= b) return seg[p];
		ll m = (l+r)/2;
		return query(a, b, 2*p, l, m)+query(a, b, 2*p+1, m+1, r);
	}
	int query(ll p) {
		return query(0, p+N, 1, 0, 2*N);
	}
	int update(ll i, int x, ll p, ll l, ll r) {
		if (i < l or r < i) return seg[p];
		if (l == r) return seg[p] += x;
		ll m = (l+r)/2;
		return seg[p] = update(i, x, 2*p, l, m)+update(i, x, 2*p+1, m+1, r);
	}
	void update(ll a, ll b, int x) {
		if (a > b) return;
		update(a+N, x, 1, 0, 2*N);	
		update(b+N+1, -x, 1, 0, 2*N);
	}
};

void pointsInsidePol(vector<ii>& pol, vector<ii>& v) {
	vector<pair<int, pair<int, ii> > > ev; // {x, {tipo, {a, b}}}
	// -1: poe ; id: query ; 1e9: tira
	for (int i = 0; i < v.size(); i++)
		ev.pb({v[i].f, {i, {v[i].s, v[i].s}}});
	for (int i = 0; i < pol.size(); i++) {
		ii u = pol[i], v = pol[(i+1)%pol.size()];
		if (u.s == v.s) {
			ev.pb({min(u.f, v.f), {-1, {u.s, u.s}}});
			ev.pb({max(u.f, v.f), {N, {u.s, u.s}}});
			continue;
		}
		int t = N;
		if (u.s > v.s) t = -1;
		ev.pb({u.f, {t, {min(u.s, v.s)+1, max(u.s, v.s)}}});
	}

	sort(ev.begin(), ev.end());
	for (int i = 0; i < v.size(); i++) ta[i] = 0;
	for (auto i : ev) {
		pair<int, ii> j = i.s;
		if (j.f == -1) seg::update(j.s.f, j.s.s, 1);
		else if (j.f == N) seg::update(j.s.f, j.s.s, -1);
		else if (seg::query(j.s.f)) ta[j.f] = 1; // ta dentro
	}
}
\end{lstlisting}

\subsection{Merge Sort Rafael}
\begin{lstlisting}
// Melhor do Brasil, segundo o autor
//
// O(n log(n))

long long merge_sort(int l, int r, vector<int> &t){
	if (l >= r) return 0;
	int m = (l+r)/2;
	auto ans = merge_sort(l, m, t) + merge_sort(m+1, r, t);
	static vector<int> aux; if (aux.size() != t.size()) aux.resize(t.size());
	for (int i = l; i <= r; i++) aux[i] = t[i];

	int i_l = l, i_r = m+1, i = l;
	auto move_l = [&](){
		t[i++] = aux[i_l++];
	};
	auto move_r = [&](){
		t[i++] = aux[i_r++];
	};

	while (i <= r){
		if (i_l > m) move_r();
		else if (i_r > r) move_l();
		else{
			if (aux[i_l] <= aux[i_r]) move_l();
			else{
				move_r();
				ans += m - i_l + 1;
			}

		}
	}
	return ans;
}

//inversions to turn r into l
template<typename T> ll inv_count(vector<T> &l, vector<T> &r){
	int n = l.size();
	map<T, int> occ;
	map<pair<T, int>, int> rk;
	for (int i = 0; i < n; i++)
		rk[make_pair(l[i], occ[l[i]]++)] = i;
	occ.clear();
	vector<int> v(n);
	for (int i = 0; i < n; i++)
		v[i] = rk[make_pair(r[i], occ[r[i]]++)];
	return merge_sort(0, n-1, v);
}
\end{lstlisting}

\subsection{Area Maxima de Histograma}
\begin{lstlisting}
// Assume que todas as barras tem largura 1,
// e altura dada no vetor v
//
// O(n)

typedef long long ll;

ll area(vector<int> v) {
	ll ret = 0;
	stack<int> s;
	// valores iniciais pra dar tudo certo
	v.insert(v.begin(), -1);
	v.insert(v.end(), -1);
	s.push(0);

	for(int i = 0; i < (int) v.size(); i++) {
		while (v[s.top()] > v[i]) {
			ll h = v[s.top()]; s.pop();
			ret = max(ret, h * (i - s.top() - 1));
		}
		s.push(i);
	}
  
	return ret;
}
\end{lstlisting}

\subsection{Distinct Range Query}
\begin{lstlisting}
// build - O(n (log n + log(sigma)))
// query - O(log(sigma))

int v[MAX], n, nxt[MAX];

namespace wav {
	vector<vector<int> > esq(4*(1+MAXN-MINN));

	void build(int b = 0, int e = n, int p = 1, int l = MINN, int r = MAXN) {
		if (l == r) return;
		int m = (l+r)/2; esq[p].push_back(0);
		for (int i = b; i < e; i++) esq[p].push_back(esq[p].back()+(nxt[i]<=m));
		int m2 = stable_partition(nxt+b, nxt+e, [=](int i){return i <= m;}) - nxt;
		build(b, m2, 2*p, l, m), build(m2, e, 2*p+1, m+1, r);
	}

	int count(int i, int j, int x, int y, int p = 1, int l = MINN, int r = MAXN) {
		if (y < l or r < x) return 0;
		if (x <= l and r <= y) return j-i;
		int m = (l+r)/2, ei = esq[p][i], ej = esq[p][j];
		return count(ei, ej, x, y, 2*p, l, m)+count(i-ei, j-ej, x, y, 2*p+1, m+1, r);
	}
}

void build() {
	for (int i = 0; i < n; i++) nxt[i] = MAXN+1;
	vector<ii> t;
	for (int i = 0; i < n; i++) t.push_back({v[i], i});
	sort(t.begin(), t.end());
	for (int i = 0; i < n-1; i++) if (t[i].f == t[i+1].f) nxt[t[i].s] = t[i+1].s;

	wav::build();
}

int query(int a, int b) {
	return wav::count(a, b+1, b+1, MAXN+1);
}
\end{lstlisting}

\subsection{Convex Hull Trick (Rafael)}
\begin{lstlisting}
// linear

struct CHT {
	int it;
	vector<ll> a, b;
	CHT():it(0){}
	ll eval(int i, ll x){
		return a[i]*x + b[i];
	}
	bool useless(){
		int sz = a.size();
		int r = sz-1, m = sz-2, l = sz-3;
		return	(b[l] - b[r])*(a[m] - a[l]) <
			(b[l] - b[m])*(a[r] - a[l]);
	}
	void add(ll A, ll B){
		a.push_back(A); b.push_back(B);
		while (!a.empty()){
			if ((a.size() < 3) || !useless()) break;
			a.erase(a.end() - 2);
			b.erase(b.end() - 2);
		}
	}
	ll get(ll x){
		it = min(it, int(a.size()) - 1);
		while (it+1 < a.size()){
			if (eval(it+1, x) > eval(it, x)) it++;
			else break;
		}
		return eval(it, x);
	}
};
\end{lstlisting}

\subsection{RMQ com Divide and Conquer}
\begin{lstlisting}
// Responde todas as queries em
// O(n log(n))

typedef pair<pair<int, int>, int> iii;
#define f first
#define s second

int n, q, v[MAX];
iii qu[MAX];
int ans[MAX], pref[MAX], sulf[MAX];

void solve(int l=0, int r=n-1, int ql=0, int qr=q-1) {
	if (l > r or ql > qr) return;
	int m = (l+r)/2;
	int qL = partition(qu+ql, qu+qr+1, [=](iii x){return x.f.s < m;}) - qu;
	int qR = partition(qu+qL, qu+qr+1, [=](iii x){return x.f.f <=m;}) - qu;

	pref[m] = sulf[m] = v[m];
	for (int i = m-1; i >= l; i--) pref[i] = min(v[i], pref[i+1]);
	for (int i = m+1; i <= r; i++) sulf[i] = min(v[i], sulf[i-1]);

	for (int i = qL; i < qR; i++)
		ans[qu[i].s] = min(pref[qu[i].f.f], sulf[qu[i].f.s]);

	solve(l, m-1, ql, qL-1), solve(m+1, r, qR, qr);
}
\end{lstlisting}

\subsection{Nim}
\begin{lstlisting}
// Calcula movimento otimo do jogo classico de Nim
// Assume que o estado atual eh perdedor
// Funcao move retorna um par com a pilha (0 indexed)
// e quanto deve ser tirado dela
// XOR deve estar armazenado em x
// Para mudar um valor, faca insere(novo_valor),
// atualize o XOR e mude o valor em v
//
// MAX2 = teto do log do maior elemento
// possivel nas pilhas
//
// O(log(n)) amortizado
 
int v[MAX], n, x;
stack<int> pi[MAX2];
 
void insere(int p) {
    for (int i = 0; i < MAX2; i++) if (v[p] & (1 << i)) pi[i].push(p);
}
 
pair<int, int> move() {
    int bit = 0; while (x >> bit) bit++; bit--;
   
    // tira os caras invalidos
    while ((v[pi[bit].top()] & (1 << bit)) == 0) pi[bit].pop();
 
    int cara = pi[bit].top();
    int tirei = v[cara] - (x^v[cara]);
    v[cara] -= tirei;
 
    insere(cara);
 
    return make_pair(cara, tirei);
}

// Acha o movimento otimo baseado
// em v apenas
//
// O(n)

pair<int, int> move() {
	int x = 0;
	for (int i = 0; i < n; i++) x ^= v[i];

	for (int i = 0; i < n; i++) if ((v[i]^x) < v[i])
		return make_pair(i, v[i] - (v[i]^x));
}
\end{lstlisting}

\subsection{Distinct Range Query com Update}
\begin{lstlisting}
// build - O(n log^2(n))
// query - O(log^2(n))
// update - O(log^2(n))

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <class T>
	using ord_set = tree<T, null_type, less<T>, rb_tree_tag,
	tree_order_statistics_node_update>;

int v[MAX], n, nxt[MAX], prv[MAX];
map<int, set<int> > ocor;

namespace seg {
	ord_set<ii> seg[4*MAX];

	void build(int p=1, int l=0, int r=n-1) {
		if (l == r) return (void)seg[p].insert({nxt[l], l});
		int m = (l+r)/2;
		build(2*p, l, m), build(2*p+1, m+1, r);
		for (ii i : seg[2*p]) seg[p].insert(i);
		for (ii i : seg[2*p+1]) seg[p].insert(i);
	}
	int query(int a, int b, int x, int p=1, int l=0, int r=n-1) {
		if (b < l or r < a) return 0;
		if (a <= l and r <= b) return seg[p].order_of_key({x, -INF});
		int m = (l+r)/2;
		return query(a, b, x, 2*p, l, m)+query(a, b, x, 2*p+1, m+1, r);
	}
	void update(int a, int x, int p=1, int l=0, int r=n-1) {
		if (a < l or r < a) return;
		seg[p].erase({nxt[a], a});
		seg[p].insert({x, a});
		if (l == r) return;
		int m = (l+r)/2;
		update(a, x, 2*p, l, m), update(a, x, 2*p+1, m+1, r);
	}
}

void build() {
	for (int i = 0; i < n; i++) nxt[i] = INF;
	for (int i = 0; i < n; i++) prv[i] = -INF;
	vector<ii> t;
	for (int i = 0; i < n; i++) t.push_back({v[i], i});
	sort(t.begin(), t.end());
	for (int i = 0; i < n; i++) {
		if (i and t[i].f == t[i-1].f) prv[t[i].s] = t[i-1].s;
		if (i+1 < n and t[i].f == t[i+1].f) nxt[t[i].s] = t[i+1].s;
	}

	for (int i = 0; i < n; i++) ocor[v[i]].insert(i);

	seg::build();
}

void muda(int p, int x) {
	seg::update(p, x);
	nxt[p] = x;
}

int query(int a, int b) {
	return b-a+1 - seg::query(a, b, b+1);
}

void update(int p, int x) { // mudar valor na pos. p para x
	if (prv[p] > -INF) muda(prv[p], nxt[p]);
	if (nxt[p] < INF) prv[nxt[p]] = prv[p];

	ocor[v[p]].erase(p);
	if (!ocor[x].size()) {
		muda(p, INF);
		prv[p] = -INF;
	} else if (*ocor[x].rbegin() < p) {
		int i = *ocor[x].rbegin();
		prv[p] = i;
		muda(p, INF);
		muda(i, p);
	} else {
		int i = *ocor[x].lower_bound(p);
		if (prv[i] > -INF) {
			muda(prv[i], p);
			prv[p] = prv[i];
		} else prv[p] = -INF;
		prv[i] = p;
		muda(p, i);
	}
	v[p] = x; ocor[x].insert(p);
}
\end{lstlisting}

\subsection{LIS1}
\begin{lstlisting}
// Calcula uma LIS
// Para ter o tamanho basta fazer lis().size()
// Implementacao do algotitmo descrito em:
// https://goo.gl/HiFkn2
//
// O(n log(n))

const int INF = 0x3f3f3f3f;

int n, v[MAX];

vector<int> lis() {
	int I[n + 1], L[n];

	// pra BB funfar bacana
	I[0] = -INF;
	for (int i = 1; i <= n; i++) I[i] = INF;

	for (int i = 0; i < n; i++) {
		// BB
		int l = 0, r = n;
		while (l < r) {
			int m = (l + r) / 2;
			if (I[m] >= v[i]) r = m;
			else l = m + 1;
		}
                
		// ultimo elemento com tamanho l eh v[i]
		I[l] = v[i];
		// tamanho da LIS terminando com o
		// elemento v[i] eh l
		L[i] = l;
	}

	// reconstroi LIS
	vector<int> ret;
	int m = -INF, p;
	for (int i = 0; i < n; i++) if (L[i] > m) {
		m = L[i];
		p = i;
	}
	ret.push_back(v[p]);
	int last = m;
	while (p--) if (L[p] == m - 1) {
		ret.push_back(v[p]);
		m = L[p];
	}

	reverse(ret.begin(), ret.end());
	return ret;
}
\end{lstlisting}

\subsection{Inversion Count}
\begin{lstlisting}
// O(n log(n))

int n;
int v[MAX];

// bit de soma
void poe(int p);
int query(int p);

// converte valores do array pra
// numeros de 1 a n
void conv() {
	vector<int> a;
	for (int i = 0; i < n; i++) a.push_back(v[i]);

	sort(a.begin(), a.end());

	for (int i = 0; i < n; i++)
		v[i] = 1 + (lower_bound(a.begin(), a.end(), v[i]) - a.begin());
}

long long inv() {
	conv();
	build();

	long long ret = 0;
	for (int i = n - 1; i >= 0; i--) {
		ret += query(v[i] - 1);
		poe(v[i]);
	}
	return ret;
}
\end{lstlisting}

\subsection{Mo algorithm - distinct values}
\begin{lstlisting}
// O(n sqrt(n) + q)

void add(int pos){
	occ[a[pos]]++;
	counter += (occ[a[pos]] == 1);
}

void remove(int pos){
	occ[a[pos]]--;
	counter -= (occ[a[pos]] == 0);
}

vector<pii> query(q);
vector<pair<pii, int>> s(q);
for (int i = 0; i < q; i++){
	int l, r;
	scanf("%d%d", &l, &r);
	l--; r--;
	query[i] = pii(l, r);
	s[i] = {{l/SQ, r}, i};
}
sort(s.begin(), s.end()); //sort queries
for (int i = 0; i < q; i++){
	int iq = s[i].second;
	pii q = query[iq];
	while (L < q.first){
		remove(L);
		L++;
	}	
	while (L > q.first){
		L--;
		add(L);
	}
	while (R < q.second){
		R++;
		add(R);
	}
	while (R > q.second){
		remove(R);
		R--;
	}
	ans[iq] = counter;
}

\end{lstlisting}

\subsection{Min fixed range}
\begin{lstlisting}
// https://codeforces.com/contest/1195/problem/E
//
// O(n)
// ans[i] = min_{0 <= j < k} v[i+j]

vector<int> min_k(vector<int> &v, int k){
	int n = v.size();
	deque<int> d;
	auto put = [&](int i){
		while (!d.empty() && v[d.back()] > v[i])
			d.pop_back();
		d.push_back(i);
	};
	for (int i = 0; i < k-1; i++)
		put(i);
	vector<int> ans(n-k+1);
	for (int i = 0; i < n-k+1; i++){
		put(i+k-1);
		while (i > d.front()) d.pop_front();
		ans[i] = v[d.front()];
	}
	return ans;
}
\end{lstlisting}

\subsection{Mininum Enclosing Circle Vasek}
\begin{lstlisting}
// O(n) com alta probabilidade

const long double EPS = 1e-12;

struct pt {
	long double x, y;
	pt() {}
	pt(long double x, long double y) : x(x), y(y) {}
	pt(const pt& p) : x(p.x), y(p.y) {}
	pt operator + (const pt& p) const { return pt(x+p.x, y+p.y); }
	pt operator - (const pt& p) const { return pt(x-p.x, y-p.y); }
	pt operator * (long double c) const { return pt(x*c, y*c ); }
	pt operator / (long double c) const { return pt(x/c, y/c ); }
};

long double dot(pt p, pt q) { return p.x*q.x+p.y*q.y; }
long double dist2(pt p, pt q) { return dot(p-q, p-q); }
long double cross(pt p, pt q) { return p.x*q.y-p.y*q.x; }

pt rotate90(pt p) { return pt(p.y, -p.x); }

pt interline(pt a, pt b, pt c, pt d) {
	b = b-a; d = c-d; c = c-a;
	return a+b*cross(c, d)/cross(b, d);	
}

pt center(pt a, pt b, pt c) {
	b = (a+b)/2;
	c = (a+c)/2;
	return interline(b, b+rotate90(a-b), c, c+rotate90(a-c));	
}

struct circle {
	pt cen;
	long double r;
	circle() {}
	circle(pt cen, long double r) : cen(cen), r(r) {}
};

bool inside(circle& c, pt& p) {
	return c.r*c.r+1e-9 > dist2(p, c.cen);	
}

pt bestof3(pt a, pt b, pt c) {
	if (dot(b-a, c-a) < 1e-9) return (b+c)/2;
	if (dot(a-b, c-b) < 1e-9) return (a+c)/2;
	if (dot(a-c, b-c) < 1e-9) return (a+b)/2;
	return center(a, b, c);	
}

circle minCirc(vector<pt> v) {
	int n = v.size();
	random_shuffle(v.begin(), v.end());
	pt p = pt(0, 0);
	circle ret = circle(p, 0);
	for (int i = 0; i < n; i++) if (!inside(ret, v[i]))	{
		ret = circle(v[i], 0);
		for (int j = 0; j < i; j++) if (!inside(ret, v[j])) {
			ret = circle((v[i]+v[j])/2, sqrt(dist2(v[i], v[j]))/2);
			for (int k = 0; k < j; k++) if (!inside(ret, v[k])) {
				p = bestof3(v[i], v[j], v[k]);
				ret = circle(p, sqrt(dist2(p, v[i])));	
			}
		}	
	}
	return ret;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Estruturas
%
%%%%%%%%%%%%%%%%%%%%

\section{Estruturas}

\subsection{Treap}
\begin{lstlisting}
// Usar static treap<int> t;
// Para usar, chamar o Rafael
//
// Complexidades:
//
// insert - O(log(n))
// erase - O(log(n))
// query - O(log(n))

mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());

template<typename T> struct treap {
	struct node {
		int p;
		int l, r;
		T v;
		int sz;
		T sum;
		bool rev;
		node(){}
		node(T v):p(rng()), l(-1), r(-1), v(v), sz(1), rev(false){}
	} t[MAX];
	int it;
	//vector<node> t;
	treap(){ it = 0; }
	int size(int i){
		if (i == -1) return 0;
		return t[i].sz;
	}
	void fix(int i){
		if (i == -1) return;
		if (t[i].rev) {
			int &l = t[i].l;
			int &r = t[i].r;
			swap(l, r);
			t[i].sz = 1 + size(l) + size(r);
			if (l != -1)
				t[l].rev ^= true;
			if (r != -1)
				t[r].rev ^= true;
			t[i].rev = false;
		}
	}
	void update(int i){
		if (i == -1) return;
		t[i].sum = t[i].v;
		int l = t[i].l;
		int r = t[i].r;
		t[i].sz = 1 + size(l) + size(r);
	}

	void split_value(int i, int k, int &l, int &r){ //values must be ordered
		if (i == -1){
			l = -1; r = -1;
			return;
		}
		fix(i);
		if (t[i].v < k){
			split_value(t[i].r, k, l, r);
			t[i].r = l;
			l = i;
		}
		else{
			split_value(t[i].l, k, l, r);
			t[i].l = r;
			r = i;
		}
		update(i);
	}

	//implicit
	void split(int i, int k, int &l, int &r, int sz = 0){ //key
		if (i == -1){
			l = -1; r = -1;
			return;
		}
		fix(i);
		int inc = size(t[i].l); //quantidade elementos menor que k
		if (sz+inc < k){
			split(t[i].r, k, l, r, sz+inc+1);
			t[i].r = l;
			l = i;
		}
		else{
			split(t[i].l, k, l, r, sz);
			t[i].l = r;
			r = i;
		}
		update(i);
	}
	int merge(int l, int r){ //priority
		if (l == -1) return r;
		if (r == -1) return l;
		fix(l); fix(r);
		if (t[l].p > t[r].p){
			t[l].r = merge(t[l].r, r);
			update(l);
			return l;
		}
		else{
			t[r].l = merge(l, t[r].l);
			update(r);
			return r;
		}
	}

	void insert(int &root, T v, int pos){
		int m = it++;
		t[m] = node(v);
		if (root == -1){
			root = m;
			return;
		}
		int l, r;
		split(root, pos, l, r);
		l = merge(l, m);
		l = merge(l, r);
		root = l;
	}

	T query(int &root, int M){
		int l, m, r;
		split(root, M+1, m, r);
		split(m, M, l, m);

		T ans = t[m].v;
		l = merge(l, m);
		l = merge(l, r);
		root = l;
		return ans; 
	}
	void reverse(int &root, int L, int R){
		int l, m, r;
		split(root, R+1, m, r);
		split(m, L, l, m);
		t[m].rev ^= 1;
		l = merge(l, m);
		l = merge(l, r);
		root = l;
	}
	void print(int i, int &size){
		if (i == -1) return;
		print(t[i].l, size);
		cout << "#" << size << ": " << t[i].v << endl;
		size++;
		print(t[i].r, size);
	}
};
\end{lstlisting}

\subsection{SegTree 2D Iterativa}
\begin{lstlisting}
// Consultas 0-based
// Um valor inicial em (x, y) deve ser colocado em seg[x+n][y+n]
// Query: soma do retangulo ((x1, y1), (x2, y2))
// Update: muda o valor da posicao (x, y) para val
// Nao pergunte como que essa coisa funciona
//
// Para query com distancia de manhattan <= d, faca
// nx = x+y, ny = x-y
// Update em (nx, ny), query em ((nx-d, ny-d), (nx+d, ny+d))
//
// Se for de min/max, pode tirar os if's da 'query', e fazer
// sempre as 4 operacoes. Fica mais rapido
//
// Complexidades:
// build - O(n^2)
// query - O(log^2(n))
// update - O(log^2(n))

int seg[2*MAX][2*MAX], n;

void build() {
	for (int x = 2*n; x; x--) for (int y = 2*n; y; y--) {
		if (x < n) seg[x][y] = seg[2*x][y] + seg[2*x+1][y];
		if (y < n) seg[x][y] = seg[x][2*y] + seg[x][2*y+1];
	}
}

int query(int x1, int y1, int x2, int y2) {
	int ret = 0, y3 = y1 + n, y4 = y2 + n;
	for (x1 += n, x2 += n; x1 <= x2; ++x1 /= 2, --x2 /= 2)
		for (y1 = y3, y2 = y4; y1 <= y2; ++y1 /= 2, --y2 /= 2) {
			if (x1%2 == 1 and y1%2 == 1) ret += seg[x1][y1];
			if (x1%2 == 1 and y2%2 == 0) ret += seg[x1][y2];
			if (x2%2 == 0 and y1%2 == 1) ret += seg[x2][y1];
			if (x2%2 == 0 and y2%2 == 0) ret += seg[x2][y2];
		}
	
	return ret;
}

void update(int x, int y, int val) {
	int y2 = y += n;
	for (x += n; x; x /= 2, y = y2) {
		if (x >= n) seg[x][y] = val;
		else seg[x][y] = seg[2*x][y] + seg[2*x+1][y];
		
		while (y /= 2) seg[x][y] = seg[x][2*y] + seg[x][2*y+1];
	}
}
\end{lstlisting}

\subsection{SegTree}
\begin{lstlisting}
// Recursiva com Lazy Propagation
// Query: soma do range [a, b]
// Update: soma x em cada elemento do range [a, b]
//
// Complexidades:
// build - O(n)
// query - O(log(n))
// update - O(log(n))

namespace seg {
	ll seg[4*MAX], lazy[4*MAX];
	int n, *v;

	ll build(int p=1, int l=0, int r=n-1) {
		lazy[p] = 0;
		if (l == r) return seg[p] = v[l];
		int m = (l+r)/2;
		return seg[p] = build(2*p, l, m) + build(2*p+1, m+1, r);
	}
	void build(int n2, int* v2) {
		n = n2, v = v2;
		build();
	}
	void prop(int p, int l, int r) {
		seg[p] += lazy[p]*(r-l+1);
		if (l != r) lazy[2*p] += lazy[p], lazy[2*p+1] += lazy[p];
		lazy[p] = 0;
	}
	ll query(int a, int b, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) return seg[p];
		if (b < l or r < a) return 0;
		int m = (l+r)/2;
		return query(a, b, 2*p, l, m) + query(a, b, 2*p+1, m+1, r);
	}
	ll update(int a, int b, int x, int p=1, int l=0, int r=n-1) {
		prop(p, l, r);
		if (a <= l and r <= b) {
			lazy[p] += x;
			prop(p, l, r);
			return seg[p];
		}
		if (b < l or r < a) return seg[p];
		int m = (l+r)/2;
		return seg[p] = update(a, b, x, 2*p, l, m) +
			update(a, b, x, 2*p+1, m+1, r);
	}
};
\end{lstlisting}

\subsection{SegTree Iterativa com Lazy Propagation}
\begin{lstlisting}
// SegTree 1-based
// Valores iniciais devem estar em (seg[n], ... , seg[2*n-1])
// Query: soma do range [a, b], 0-based
// Update: soma x em cada elemento do range [a, b], 0-based
//
// Complexidades:
// build - O(n)
// query - O(log(n))
// update - O(log(n))

int seg[2*MAX];
int lazy[2*MAX];
int n;

void build() {
	for (int i = n - 1; i; i--) seg[i] = seg[2*i] + seg[2*i+1];
	memset(lazy, 0, sizeof(lazy));
}

// soma x na posicao p de tamanho tam
void poe(int p, int x, int tam) {
	seg[p] += x * tam;
	if (p < n) lazy[p] += x;
}

// atualiza todos os pais da folha p
void sobe(int p) {
	for (int tam = 2; p /= 2; tam *= 2)
		seg[p] = seg[2*p] + seg[2*p+1] + lazy[p] * tam;
}

// propaga o caminho da raiz ate a folha p
void prop(int p) {
	int tam = 1 << 29;
	for (int s = 30; s; s--, tam /= 2) {
		int i = p >> s;
		if (lazy[i]) {
			poe(2*i, lazy[i], tam);
			poe(2*i+1, lazy[i], tam);
			lazy[i] = 0;
		}
	}
}

int query(int a, int b) {
	prop(a += n), prop(b += n);
	int ret = 0;
	for(; a <= b; a /= 2, b /= 2) {
		if (a % 2 == 1) ret += seg[a++];
		if (b % 2 == 0) ret += seg[b--];
	}
	return ret;
}

void update(int a, int b, int x) {
	int a2 = a += n, b2 = b += n, tam = 1;
	for (; a <= b; a /= 2, b /= 2, tam *= 2) {
		if (a % 2 == 1) poe(a++, x, tam);
		if (b % 2 == 0) poe(b--, x, tam);
	}
	sobe(a2), sobe(b2);
}
\end{lstlisting}

\subsection{SegTree Esparca}
\begin{lstlisting}
// Query: soma do range [a, b]
// Update: flipa os valores de [a, b]
//
// Complexidades:
// build - O(n)
// query - O(log^2(n))
// update - O(log^2(n))

typedef long long ll;

namespace seg {
	unordered_map<ll, int> t, laz;

	void build() { t.clear(), lazy.clear(); }

	void prop(ll p, int l, int r) {
		if (!lazy[p]) return;
		t[p] = r-l+1-t[p];
		if (l != r) lazy[2*p]^=lazy[p], lazy[2*p+1]^=lazy[p];
		lazy[p] = 0;
	}

	int query(int a, int b, ll p=1, int l=0, int r=N-1) {
		prop(p, l, r);
		if (b < l or r < a) return 0;
		if (a <= l and r <= b) return t[p];

		int m = l+r>>1;
		return query(a, b, 2*p, l, m)+query(a, b, 2*p+1, m+1, r);
	}

	int update(int a, int b, ll p=1, int l=0, int r=N-1) {
		prop(p, l, r);
		if (b < l or r < a) return t[p];
		if (a <= l and r <= b) {
			lazy[p] ^= 1;
			prop(p, l, r);
			return t[p];
		}
		int m = l+r>>1;
		return t[p] = update(a, b, 2*p, l, m)+update(a, b, 2*p+1, m+1, r);
	}
};
\end{lstlisting}

\subsection{SegTree Iterativa}
\begin{lstlisting}
// Consultas 0-based
// Valores iniciais devem estar em (seg[n], ... , seg[2*n-1])
// Query: soma do range [a, b]
// Update: muda o valor da posicao p para x
//
// Complexidades:
// build - O(n)
// query - O(log(n))
// update - O(log(n))

int seg[2 * MAX];
int n;

void build() {
	for (int i = n - 1; i; i--) seg[i] = seg[2*i] + seg[2*i+1];
}

int query(int a, int b) {
	int ret = 0;
	for(a += n, b += n; a <= b; ++a /= 2, --b /= 2) {
		if (a % 2 == 1) ret += seg[a];
		if (b % 2 == 0) ret += seg[b];
	}
	return ret;
}

void update(int p, int x) {
	seg[p += n] = x;
	while (p /= 2) seg[p] = seg[2*p] + seg[2*p+1];
}
\end{lstlisting}

\subsection{BIT 2D}
\begin{lstlisting}
// BIT de soma 1-based
// Para mudar o valor da posicao (x, y) para k,
// faca: poe(x, y, k - sum(x, y, x, y))
//
// Complexidades:
// poe - O(log^2(n))
// query - O(log^2(n))

int n;
int bit[MAX][MAX];

void poe(int x, int y, int k) {
	for (int y2 = y; x <= n; x += x & -x)
		for (y = y2; y <= n; y += y & -y)
			bit[x][y] += k;
}

int sum(int x, int y) {
	int ret = 0;
	for (int y2 = y; x; x -= x & -x)
		for (y = y2; y; y -= y & -y)
			ret += bit[x][y];

	return ret;
}

int query(int x, int y, int z, int w) {
	return sum(z, w) - sum(x-1, w)
		- sum(z, y-1) + sum(x-1, y-1);
}
\end{lstlisting}

\subsection{DSU Persistente}
\begin{lstlisting}
// Complexidades:
// build - O(n)
// find - O(log(n))
// une - O(log(n))

int n, p[MAX], sz[MAX], ti[MAX];

void build() {
	for (int i = 0; i < n; i++) {
		p[i] = i;
		sz[i] = 1;
		ti[i] = -INF;
	}
}

int find(int k, int t) {
	if (p[k] == k or ti[k] > t) return k;
	return find(p[k], t);
}

void une(int a, int b, int t) {
	a = find(a); b = find(b);
	if (a == b) return;
	if (sz[a] > sz[b]) swap(a, b);

	sz[b] += sz[a];
	p[a] = b;
	ti[a] = t;
}
\end{lstlisting}

\subsection{Order Statistic Set}
\begin{lstlisting}
// Funciona do C++11 pra cima

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <class T>
	using ord_set = tree<T, null_type, less<T>, rb_tree_tag,
	tree_order_statistics_node_update>;
	
// para declarar:
ord_set<int> s;
// coisas do set normal funcionam:
for (auto i : s) cout << i << endl;
cout << s.size() << endl;
// k-esimo maior elemento O(log|s|):
// k=0: menor elemento
cout << *s.find_by_order(k) << endl;
// quantos sao menores do que k O(log|s|):
cout << s.order_of_key(k) << endl;

// Para fazer um multiset, tem que
// usar ord_set<pair<int, int> > com o
// segundo parametro sendo algo para diferenciar
// os ementos iguais.
// s.order_of_key({k, -INF}) vai retornar o
// numero de elementos < k
\end{lstlisting}

\subsection{SQRT-decomposition}
\begin{lstlisting}
// Resolve RMQ
// 0-indexed
// MAX2 = sqrt(MAX)
//
// O bloco da posicao x eh
// sempre x/q
//
// Complexidades:
// build - O(n)
// query - O(sqrt(n))

int n, q;
int v[MAX];
int bl[MAX2];

void build() {
	q = (int) sqrt(n);
  
 	 // computa cada bloco
	for (int i = 0; i <= q; i++) {
		bl[i] = INF;
		for (int j = 0; j < q and q * i + j < n; j++)
			bl[i] = min(bl[i], v[q * i + j]);
	}
}

int query(int a, int b) {
	int ret = INF;

	// linear no bloco de a
	for (; a <= b and a % q; a++) ret = min(ret, v[a]);

	// bloco por bloco
	for (; a + q <= b; a += q) ret = min(ret, bl[a / q]);

	// linear no bloco de b
	for (; a <= b; a++) ret = min(ret, v[a]);

	return ret;
}
\end{lstlisting}

\subsection{Sparse Table}
\begin{lstlisting}
// Resolve RMQ
// MAX2 = log(MAX)
//
// Complexidades:
// build - O(n log(n))
// query - O(1)

int n;
int v[MAX];
int m[MAX][MAX2]; // m[i][j] : posicao do minimo
                  // em [v[i], v[i + 2^j - 1]]

void build() {
	for (int i = 0; i < n; i++) m[i][0] = i;

	for (int j = 1; 1 << j <= n; j++) {
		int tam = 1 << j;
		for (int i = 0; i + tam <= n; i++) {
			if (v[m[i][j - 1]] < v[m[i + tam/2][j - 1]])
				m[i][j] = m[i][j - 1];
			else m[i][j] = m[i + tam/2][j - 1];
		}
	}
}

int query(int a, int b) {
	int j = (int) log2(b - a + 1);

	return min(v[m[a][j]], v[m[b - (1 << j) + 1][j]]);
}
\end{lstlisting}

\subsection{MergeSort Tree}
\begin{lstlisting}
// query(a, b, val) retorna numero de
// elementos em [a, b] <= val
// Usa O(n log(n)) de memoria
//
// Complexidades:
// build - O(n log(n))
// query - O(log^2(n))

#define ALL(x) x.begin(),x.end()

int v[MAX], n;
vector<vector<int> > tree(4*MAX);

void build(int p, int l, int r) {
	if (l == r) return tree[p].push_back(v[l]);
	int m = (l+r)/2;
	build(2*p, l, m), build(2*p+1, m+1, r);
	merge(ALL(tree[2*p]), ALL(tree[2*p+1]), back_inserter(tree[p]));
}

int query(int a, int b, int val, int p=1, int l=0, int r=n-1) {
	if (b < l or r < a) return 0; // to fora
	if (a <= l and r <= b) // to totalmente dentro
		return lower_bound(ALL(tree[p]), val+1) - tree[p].begin();
	int m = (l+r)/2;
	return query(a, b, val, 2*p, l, m) + query(a, b, val, 2*p+1, m+1, r);
}
\end{lstlisting}

\subsection{Wavelet Tree}
\begin{lstlisting}
// Usa O(sigma + n log(sigma)) de memoria,
// onde sigma = MAXN - MINN
// Depois do build, o v fica ordenado
// count(i, j, x, y) retorna o numero de elementos de
// v[i, j) que pertencem a [x, y]
// kth(i, j, k) retorna o elemento que estaria
// na poscicao k-1 de v[i, j), se ele fosse ordenado
// sum(i, j, x, y) retorna a soma dos elementos de
// v[i, j) que pertencem a [x, y]
// sumk(i, j, k) retorna a soma dos k-esimos menores
// elementos de v[i, j) (sum(i, j, 1) retorna o menor)
//
// Complexidades:
// build - O(n log(sigma))
// count - O(log(sigma))
// kth   - O(log(sigma))
// sum   - O(log(sigma))
// sumk  - O(log(sigma))

int n, v[MAX];
vector<vector<int> > esq(4*(MAXN-MINN)), pref(4*(MAXN-MINN));

void build(int b = 0, int e = n, int p = 1, int l = MINN, int r = MAXN) {
	int m = (l+r)/2; esq[p].push_back(0); pref[p].push_back(0);
	for (int i = b; i < e; i++) {
		esq[p].push_back(esq[p].back()+(v[i]<=m));
		pref[p].push_back(pref[p].back()+v[i]);
	}
	if (l == r) return;
	int m2 = stable_partition(v+b, v+e, [=](int i){return i <= m;}) - v;
	build(b, m2, 2*p, l, m), build(m2, e, 2*p+1, m+1, r);
}

int count(int i, int j, int x, int y, int p = 1, int l = MINN, int r = MAXN) {
	if (y < l or r < x) return 0;
	if (x <= l and r <= y) return j-i;
	int m = (l+r)/2, ei = esq[p][i], ej = esq[p][j];
	return count(ei, ej, x, y, 2*p, l, m)+count(i-ei, j-ej, x, y, 2*p+1, m+1, r);
}

int kth(int i, int j, int k, int p=1, int l = MINN, int r = MAXN) {
	if (l == r) return l;
	int m = (l+r)/2, ei = esq[p][i], ej = esq[p][j];
	if (k <= ej-ei) return kth(ei, ej, k, 2*p, l, m);
	return kth(i-ei, j-ej, k-(ej-ei), 2*p+1, m+1, r);
}

int sum(int i, int j, int x, int y, int p = 1, int l = MINN, int r = MAXN) {
	if (y < l or r < x) return 0;
	if (x <= l and r <= y) return pref[p][j]-pref[p][i];
	int m = (l+r)/2, ei = esq[p][i], ej = esq[p][j];
	return sum(ei, ej, x, y, 2*p, l, m) + sum(i-ei, j-ej, x, y, 2*p+1, m+1, r);
}

int sumk(int i, int j, int k, int p = 1, int l = MINN, int r = MAXN) {
	if (l == r) return l*k;
	int m = (l+r)/2, ei = esq[p][i], ej = esq[p][j];
	if (k <= ej-ei) return sumk(ei, ej, k, 2*p, l, m);
	return pref[2*p][ej]-pref[2*p][ei]+sumk(i-ei, j-ej, k-(ej-ei), 2*p+1, m+1, r);
}
\end{lstlisting}

\subsection{Trie}
\begin{lstlisting}
// N deve ser maior ou igual ao numero de nos da trie
// fim indica se alguma palavra acaba nesse no
//
// Complexidade:
// Inserir e conferir string S -> O(|S|)

// usar static trie T
// T.insert(s) para inserir
// T.find(s) para ver se ta
// T.prefix(s) printa as strings
// que tem s como prefixo

struct trie{
	map<char, int> t[MAX+5];
	int p;
	trie(){
		p = 1;
	}
	void insert(string s){
		s += '$';
		int i = 0;
		for (char c : s){
			auto it = t[i].find(c);
			if (it == t[i].end())
				i = t[i][c] = p++;
			else
				i = it->second;
		}
	}
	bool find(string s){
		s += '$';
		int i = 0;
		for (char c : s){
			auto it = t[i].find(c);
			if (it == t[i].end()) return false;
			i = it->second;
		}
		return true;
	}
	void prefix(string &l, int i){
		if (t[i].find('$') != t[i].end())
			cout << "  " << l << endl;	
		for (auto p : t[i]){
			l += p.first;
			prefix(l, p.second, k);
			l.pop_back();
		}
	}
	void prefix(string s){
		int i = 0;
		for (char c : s){
			auto it = t[i].find(c);
			if (it == t[i].end()) return;
			i = it->second;
		}
		int k = 0;
		prefix(s, i, k);
	}
};
\end{lstlisting}

\subsection{BIT}
\begin{lstlisting}
// BIT de soma 1-based, v 0-based
// Para mudar o valor da posicao p para x,
// faca: poe(x - query(p, p), p)
// l_bound(x) retorna o menor p tal que
// query(1, p+1) > x    (0 based!)
//
// Complexidades:
// build - O(n)
// poe - O(log(n))
// query - O(log(n))
// l_bound - O(log(n))

int n;
int bit[MAX];
int v[MAX];

void build() {
	bit[0] = 0;
	for (int i = 1; i <= n; i++) bit[i] = v[i - 1];

	for (int i = 1; i <= n; i++) {
		int j = i + (i & -i);
		if (j <= n) bit[j] += bit[i];
	}
}

// soma x na posicao p
void poe(int x, int p) {
	for (; p <= n; p += p & -p) bit[p] += x;
}

// soma [1, p]
int pref(int p) {
	int ret = 0;
	for (; p; p -= p & -p) ret += bit[p];
	return ret;
}

// soma [a, b]
int query(int a, int b) {
	return pref(b) - pref(a - 1);
}

int l_bound(ll x) {
	int p = 0;
	for (int i = MAX2; i+1; i--) if (p + (1<<i) <= n
		and bit[p + (1<<i)] <= x) x -= bit[p += (1<<i)];
	return p;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Papa
%
%%%%%%%%%%%%%%%%%%%%

\section{Papa}

\subsection{Baby step Giant step}
\begin{lstlisting}
// Resolve Logaritmo Discreto a^x = b mod m, m primo em O(sqrt(n)*hash(n))
// Meet In The Middle, decompondo x = i * ceil(sqrt(n)) -j, i,j<=ceil(sqrt(n))

int babyStep(int a,int b,int m)
{
	unordered_map<int,int> mapp;
	int sq=sqrt(m)+1;
	ll asq=1;
	for(int i=0; i<sq; i++)
		asq=(asq*a)%m;
	ll curr=asq;
	for(int i=1; i<=sq; i++)
	{
		if(!mapp.count(curr))
			mapp[curr]=i;
		curr=(curr*asq)%m;
	}
	int ret=INF;
	curr=b;
	for(int j=0; j<=sq; j++)
	{
		if(mapp.count(curr))
			ret=min(ret,(int)(mapp[curr]*sq-j));
		curr=(curr*a)%m;
	}
	if(ret<INF) return ret;
	return -1;
}
int main()
{
	int a,b,m;
	while(cin>>a>>b>>m,a or b or m)
	{
		int x=babyStep(a,m,b);
		if(x!=-1)
			cout<<x<<endl;
		else
			cout<<"No Solution"<<endl;
	}
	return 0;
}
\end{lstlisting}

\subsection{LIS Rec. Resp.}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
#define sc(a) scanf("%d", &a)

typedef long long int ll;
const int INF = 0x3f3f3f3f;

#define MAXN 100100
int aux[MAXN],endLis[MAXN];
//usar upper_bound se puder >=
vector<int> LisRec(vector<int> v){
	int n=v.size();
	int lis=0;
	for (int i = 0; i < n; i++){
		int it = lower_bound(aux, aux+lis, v[i]) - aux;
		endLis[i] = it+1;
		lis = max(lis, it+1);
		aux[it] = v[i];
	}
	vector<int> resp;
	int prev=INF;
	for(int i=n-1;i>=0;i--){
		if(endLis[i]==lis && v[i]<=prev){
			lis--;
			prev=v[i];
			resp.push_back(i);
		}
	}
	reverse(resp.begin(),resp.end());
	return resp;
}

int main()
{
	int n;
	sc(n);
	vector<int> v(n);
	for(int i=0;i<n;i++)
		sc(v[i]);
	cout<<LisRec(v).size()<<endl;
	return 0;
}
\end{lstlisting}

\subsection{Aho Corasick}
\begin{lstlisting}
const int N=100010;
const int M=26;
//N= tamanho da trie, M tamanho do alfabeto
int to[N][M], Link[N], fim[N];
int idx = 1;
void add_str(string &s)
{
	int v = 0;
	for (int i = 0; i < s.size(); i++) {
		if (!to[v][s[i]]) to[v][s[i]] = idx++;
		v = to[v][s[i]];
	}
	fim[v] = 1;
}

void process()
{
	queue<int> fila;
	fila.push(0);
	while (!fila.empty()) {
		int cur = fila.front();
		fila.pop();
		int l = Link[cur];
		fim[cur] |= fim[l];
		for (int i = 0; i < M; i++) {
			if (to[cur][i]) {
				if (cur != 0) {
					Link[to[cur][i]] = to[l][i];
				}
				else
					Link[to[cur][i]] = 0;
				fila.push(to[cur][i]);
			}
			else {
				to[cur][i] = to[l][i];
			}
		}
	}
}

int resolve(string &s)
{
	int v = 0, r = 0;
	for (int i = 0; i < s.size(); i++) {
		v = to[v][s[i]];
		if (fim[v]) r++, v = 0;
	}
	return r;
}
\end{lstlisting}

\subsection{BIT Persistente}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;

typedef long long int ll;

const ll LINF = 0x3f3f3f3f3f3f3f3fll;

#define MAXN 100010
vector<pair<int,ll> > FT[MAXN];
int n;
void clear()
{
	for(int i=1;i<=n;i++)
	{
		FT[i].clear();
		FT[i].push_back({-1,0});
	}
}
void add(int i,int v,int time)
{
	for(;i<=n;i+=i&(-i))
	{
		ll last=FT[i].back().second;
		FT[i].push_back({time,last+v});
	}
}
ll get(int i,int time)
{
	ll ret=0;
	for(;i>0;i-=i&(-i))
	{
		int pos = upper_bound(FT[i].begin(),FT[i].end(),
					make_pair(time,LINF))-FT[i].begin()-1;
		ret+=FT[i][pos].second;
	}
	return ret;
}
ll getRange(int a,int b,int time)
{
	return get(b,time)-get(a-1,time);
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Matematica
%
%%%%%%%%%%%%%%%%%%%%

\section{Matematica}

\subsection{Produto de dois long long mod m}
\begin{lstlisting}
// O(1)

typedef long long int ll;

ll mul(ll a, ll b, ll m) { // a*b % m
	return (a*b-ll(a*(long double)b/m+0.5)*m+m)%m;	
}
\end{lstlisting}

\subsection{Exponenciacao rapida}
\begin{lstlisting}
// (x^y mod m) em O(log(y))

typedef long long int ll;

ll pow(ll x, ll y, ll m) { // iterativo
	ll ret = 1;
	while (y) {
		if (y & 1) ret = (ret * x) % m;
		y >>= 1;
		x = (x * x) % m;
	}
	return ret;
}

ll pow(ll x, ll y, ll m) { // recursivo
	if (!y) return 1;
	ll ans = pow(x*x, y/2, m);
	return y%2 ? x*ans : ans;
}
\end{lstlisting}

\subsection{Divisão de Polinomios}
\begin{lstlisting}
// Divide p1 por p2
// Retorna um par com o quociente e o resto
// Os coeficientes devem estar em ordem
// decrescente pelo grau. Ex:
// 3x^2 + 2x - 1 -> [3, 2, -1]
//
// O(nm), onde n e m sao os tamanhos dos
// polinomios

typedef vector<int> vi;

pair<vi, vi> div(vi p1, vi p2) {
	vi quoc, resto;
	int a = p1.size(), b = p2.size();
	for (int i = 0; i <= a - b; i++) {
		int k = p1[i] / p2[0];
		quoc.pb(k);
		for (int j = i; j < i + b; j++)
			p1[j] -= k * p2[j - i];
	}

	for (int i = a - b + 1; i < a; i++)
		resto.pb(p1[i]);

	return mp(quoc, resto);
}
\end{lstlisting}

\subsection{Totiente}
\begin{lstlisting}
// O(sqrt(n))

int tot(int n){
	int ret = n;

	for (int i = 2; i*i <= n; i++) if (n % i == 0) {
		while (n % i == 0) n /= i;
		ret -= ret / i;
	}
	if (n > 1) ret -= ret / n;

	return ret;
}
\end{lstlisting}

\subsection{Ordem de elemento do grupo}
\begin{lstlisting}
// Calcula a ordem de a em Z_n
// O grupo Zn eh ciclico sse n = 
// 1, 2, 4, p^k ou 2 p^k, p primo impar
// Retorna -1 se nao achar
//
// O(sqrt(n) log(n))

int tot(int n); // totiente em O(sqrt(n))
int expo(int a, int b, int m); // (a^b)%m em O(log(b))

// acha todos os divisores ordenados em O(sqrt(n))
vector<int> div(int n) {
	vector<int> ret1, ret2;
	for (int i = 1; i*i <= n; i++) if (n % i == 0) {
		ret1.pb(i);
		if (i*i != n) ret2.pb(n/i);
	}

	for (int i = ret2.size()-1; i+1; i--) ret1.pb(ret2[i]);
	return ret1;
}

int ordem(int a, int n) {
	vector<int> v = div(tot(n));
	for (int i : v) if (expo(a, i, n) == 1) return i;
	return -1;
}
\end{lstlisting}

\subsection{Inverso Modular}
\begin{lstlisting}
// Computa o inverso de a modulo b
// Se b eh primo, basta fazer
// a^(b-2)

long long inv(long long a, long long b){
	return 1<a ? b - inv(b%a,a)*b/a : 1;
}
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
// Exemplos na main
//
// Soma O(n) & Multiplicacao O(nlogn)

const int MAX = 5e5;
const int MAX2 = (1 << 20);//(1 << (ceil(log2(MAX)) + 1)) + 1

const double PI = acos(-1);

struct cplx{
	double r, i;
	cplx(double r_ = 0, double i_ = 0):r(r_), i(i_){}
	const cplx operator+(const cplx &x) const{
		return cplx(r + x.r, i + x.i);
	}
	const cplx operator-(const cplx &x) const{
		return cplx(r - x.r, i - x.i);
	}
	const cplx operator*(double a) const {
		return cplx(r*a, i*a);
	}
	const cplx operator/(double a)const {
		return cplx(r/a, i/a);
	}
	const cplx operator*(const cplx x) const {
		return cplx(r*x.r - i*x.i, r*x.i + i*x.r);
	}
};

const cplx I(0, 1);
cplx X[MAX2], Y[MAX2];
int rev[MAX2];
cplx roots[MAX2];

cplx rt(int i, int n){
	double alpha = (2*i*PI)/n;
	return cplx(cos(alpha), sin(alpha));
}

void fft(cplx *a, bool f, int N){
	for (int i = 0; i < N; i++)
		if (i < rev[i])
			swap(a[i], a[rev[i]]);
	int l, r, m;
	for (int n = 2; n <= N; n *= 2){
		cplx root = (f ? rt(1, n) : rt(-1, n));
		roots[0] = 1;
		for (int i = 1; i < n/2; i++)
			roots[i] = roots[i-1]*root;
		for (int pos = 0; pos < N; pos += n){
			l = pos+0, r = pos+n/2, m = 0;
			while (m < n/2){
				auto t = roots[m]*a[r];
				a[r] = a[l] - t;
				a[l] = a[l] + t;
				l++; r++; m++;
			}
		}
	}
	if (f) for(int i = 0; i < N; i++) a[i] = a[i]/N;
}


//p(x) = at(i)*x^i
template<typename T> struct poly : vector<T> {
	poly(const vector<T> &coef):vector<T>(coef){}
	poly(unsigned size):vector<T>(size){}
	poly(){}
	T operator()(T x){
		T ans = 0, curr_x(1);
		for (auto c : *this) {
			ans = ans+c*curr_x;
			curr_x = curr_x*x;
		}
		return ans;
	}
	poly<T> operator+(const poly<T> &r){
		const poly<T> &l = *this;
		int sz = max(l.size(), r.size());
		poly<T> ans(sz);
		for (unsigned i = 0; i < l.size(); i++)
			ans[i] = ans[i]+l[i];
		for (unsigned i = 0; i < r.size(); i++)
			ans[i] = ans[i]+r[i];
		return ans;
	}
	poly<T> operator-(poly<T> &r){
		for (auto &it : r) it = -it;
		return (*this)+r;
	}
	void fix(int k){
		if (k < this->size()) throw logic_error("normalizando errado");
		while (this->size() < k) this->push_back(0);
	}
	pair<poly<T>, poly<T>> split(){
		const poly<T> &p = *this;
		poly<T> l, r;
		for (int i = 0; i < p.size(); i++)
			if (i&1) l.push_back(p[i]);
			else r.push_back(p[i]);
		return {l, r};
	}
	poly<T> operator*(const poly<T> r){
		const poly<T> &l = *this;
		int ln = l.size(), rn = r.size();
		int N = ln+rn+1;
		int n = 1, log_n = 0;
		while (n <= N) { n <<= 1; log_n++; }
		for (int i = 0; i < n; ++i){
			rev[i] = 0;
			for (int j = 0; j < log_n; ++j)
				if (i & (1<<j))
					rev[i] |= 1 << (log_n-1-j);
		}
		for (int i = 0; i < ln; i++) X[i] = l[i];
		for (int i = ln; i < n; i++) X[i] = 0;
		for (int i = 0; i < rn; i++) Y[i] = r[i];
		for (int i = rn; i < n; i++) Y[i] = 0;
		fft(X, false, n);//call dft if possible
		fft(Y, false, n);

		for (int i = 0; i < n; i++)
			Y[i] = X[i]*Y[i];

		fft(Y, true, n);
		poly<T> ans(N);
		for (int i = 0; i < N; i++){
			ans[i] = floor(Y[i].r + 0.25); //if T is integer
			//ans[i] = Y[i].r; //if T is floating point
		}
			

		while (!ans.empty() && ans.back() == 0)
			ans.pop_back();
		return ans;
	}
	pair<poly<T>, T> briot_ruffini(T r){//for p = Q(x - r) + R, returns (Q, R)
		const poly<T> &l = *this;
		int sz = l.size();
		if (sz == 0) return {poly<T>(0), 0};
		poly<T> q(sz - 1);
		q.back() = l.back();
		for (int i = q.size()-2; i >= 0; i--){
			cout << i << "~" << q.size() << endl;
			q[i] = q[i+1]*r + l[i+1];
		}
		return {q, q[0]*r + l[0]};
	}
};
template<typename T> ostream& operator<<(ostream &out, const poly<T> &p){
	if (p.empty()) return out;
	out << p.at(0);
	for (int i = 1; i < p.size(); i++)
		out << " + " << p.at(i) << "x^" << i;
	out << endl;
	return out;
}

int main(){ _
	poly<int> p({-2, -1, 2, 1});
	poly<int> q({1, 1, 1});
	poly<int> sum = p+q;
	poly<int> mult = p*q;
	cout << "p: " << p << endl;
	cout << "q: " << q << endl;
	cout << "pq: " << mult << endl;
	for (int i = 1; i <= 50; i++){
		auto P = p(i), Q = q(i), M = mult(i);
		cout << P*Q << "\t\tvs\t\t" << M << endl;
		if (abs(P*Q - M) > 1e-5) throw logic_error("bad implementation :(");
	}
	cout << "sucesso!" << endl;
	exit(0);
	for (int root : {1, -1, 2, -2, 3}){
		poly<int> t; int r;
		tie(t, r) = p.briot_ruffini(root);
		cout << p << "/" << poly<int>({-root, 1});
		cout << " = " << endl;
		cout << t << " + " << r << endl;
		cout << endl;
	}

	exit(0);
}
\end{lstlisting}

\subsection{Miller-Rabin}
\begin{lstlisting}
// Testa se n eh primo, n <= 3 * 10^18
//
// O(log(n)), considerando multiplicacao
// e exponenciacao constantes

// multiplicacao modular
ll mul(ll x, ll y, ll m); // x*y mod m
ll exp(ll x, ll y, ll m); // x^y mod m;

bool prime(ll n) {
	if (n < 2) return 0;
	if (n <= 3) return 1;
	if (n % 2 == 0) return 0;

	ll d = n - 1;
	int r = 0;
	while (d % 2 == 0) r++, d /= 2;

 	// com esses primos, o teste funciona garantido para n <= 3*10^18
	// funciona para n <= 3*10^24 com os primos ate 41
	int a[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
	// outra opcao para n <= 2^64:
	// int a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};

	for (int i = 0; i < 9; i++) {
		if (a[i] >= n) break;
		ll x = exp(a[i], d, n);
		if (x == 1 or x == n - 1) continue;

		bool deu = 1;
		for (int j = 0; j < r - 1; j++) {
			x = mul(x, x, n);
			if (x == n - 1) {
				deu = 0;
				break;
			}
		}
		if (deu) return 0;
	}
	return 1;
}
\end{lstlisting}

\subsection{Variacoes do crivo de Eratosthenes}
\begin{lstlisting}
// "O" crivo
//
// Encontra maior divisor primo
// Um numero eh primo sse div[x] == x
// fact fatora um numero <= lim
// A fatoracao sai ordenada
//
// crivo - O(n log(log(n)))
// fact - O(log(n))

int divi[MAX];

void crivo(int lim) {
	for (int i = 1; i <= lim; i++) divi[i] = 1;

	for (int i = 2; i <= lim; i++) if (divi[i] == 1)
		for (int j = i; j <= lim; j += i) divi[j] = i;
}

void fact(vector<int>& v, int n) {
	if (n != divi[n]) fact(v, n/divi[n]);
	v.push_back(divi[n]);
}

// Crivo de divisores
//
// Encontra numero de divisores
// ou soma dos divisores
//
// O(n log(n))

int divi[MAX];

void crivo(int lim) {
	for (int i = 1; i <= lim; i++) divi[i] = 1;

	for (int i = 2; i <= lim; i++)
		for (int j = i; j <= lim; j += i) {
			// para numero de divisores
			divi[j]++;
			// para soma dos divisores
			divi[j] += i;
		}
}

// Crivo de totiente
//
// Encontra o valor da funcao
// totiente de Euler
//
// O(n log(log(n)))

int tot[MAX];

void crivo(int lim) {
	for (int i = 1; i <= lim; i++) tot[i] = i;

	for (int i = 2; i <= lim; i++) if (tot[i] == i)
		for (int j = i; j <= lim; j += i)
			tot[j] -= tot[j] / i;
}
\end{lstlisting}

\subsection{Algoritmo de Euclides}
\begin{lstlisting}
// O(log(min(a, b)))

int mdc(int a, int b) {
	return !b ? a : mdc(b, a % b);
}
\end{lstlisting}

\subsection{Pollard's Rho Alg}
\begin{lstlisting}
// Usa o algoritmo de deteccao de ciclo de Brent
// A fatoracao nao sai necessariamente ordenada
// O algoritmo rho encontra um fator de n,
// e funciona muito bem quando n possui um fator pequeno
// Eh recomendado chamar srand(time(NULL)) na main
//
// Complexidades (considerando mul constante):
// rho - esperado O(n^(1/4)) no pior caso
// fact - esperado menos que O(n^(1/4) log(n)) no pior caso

ll mdc(ll a, ll b) { return !b ? a : mdc(b, a % b); }

ll mul(ll a, ll b, ll m) {
	return (a*b-ll(a*(long double)b/m+0.5)*m+m)%m;	
}

ll exp(ll a, ll b, ll m) {
	if (!b) return 1;
	ll ans = exp(mul(a, a, m), b/2, m);
	return b%2 ? mul(a, ans, m) : ans;
}

bool prime(ll n) {
	if (n < 2) return 0;
	if (n <= 3) return 1;
	if (n % 2 == 0) return 0;

	ll d = n - 1;
	int r = 0;
	while (d % 2 == 0) {
		r++;
		d /= 2;
	}

	int a[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
	for (int i = 0; i < 9; i++) {
		if (a[i] >= n) break;
		ll x = exp(a[i], d, n);
		if (x == 1 or x == n - 1) continue;

		bool deu = 1;
		for (int j = 0; j < r - 1; j++) {
			x = mul(x, x, n);
			if (x == n - 1) {
				deu = 0;
				break;
			}
		}
		if (deu) return 0;
	}
	return 1;
}

ll rho(ll n) {
	if (n == 1 or prime(n)) return n;
	if (n % 2 == 0) return 2;

	while (1) {
		ll x = 2, y = 2;
		ll ciclo = 2, i = 0;

		ll c = (rand() / (double) RAND_MAX) * (n - 1) + 1;
		ll d = 1;

		while (d == 1) {
			if (++i == ciclo) ciclo *= 2, y = x;
			x = (mul(x, x, n) + c) % n;

			if (x == y) break;

			d = mdc(abs(x - y), n);
		}

		if (x != y) return d;
	}
}

void fact(ll n, vector<ll>& v) {
	if (n == 1) return;
	if (prime(n)) v.pb(n);
	else {
		ll d = rho(n);
		fact(d, v);
		fact(n / d, v);
	}
}
\end{lstlisting}

\subsection{Algoritmo de Euclides extendido}
\begin{lstlisting}
// acha x e y tal que ax + by = mdc(a, b)
//
// O(log(min(a, b)))

int mdce(int a, int b, int *x, int *y){
	if(!a){
		*x = 0;
		*y = 1;
		return b;
	}

	int X, Y;
	int mdc = mdce(b % a, a, &X, &Y);
	*x = Y - (b / a) * X;
	*y = X;

	return mdc;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{vimrc}
\begin{lstlisting}
set ts=4 si ai sw=4 number mouse=a
syntax on
\end{lstlisting}

\subsection{makefile}
\begin{lstlisting}
CXX = g++
CXXFLAGS = -fsanitize=address -O1 -fno-omit-frame-pointer -g -Wall -Wshadow -std=c++14 -Wno-unused-result -Wno-sign-compare

CXXFLAGS = -fsanitize=address,undefined -fno-sanitize-recover=all -D_GLIBCXX_DEBUG -O1 -fno-omit-frame-pointer -g -Wall -Wshadow -Wconversion -std=c++14 -Wno-unused-result -Wno-sign-compare
\end{lstlisting}

\subsection{template.cpp}
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

#define _ ios_base::sync_with_stdio(0);cin.tie(0);
#define endl '\n'
#define f first
#define s second
#define pb push_back

typedef long long ll;
typedef pair<int, int> ii;

const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3fll;

int main(){ _
	exit(0);
}
\end{lstlisting}

\end{document}
